#! /usr/bin/env python

# Copyright (C) 2018- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

import sys
import os
import subprocess
import shlex
import shutil
import distutils
import uuid
import platform
import threading
import getopt
import re

######## Configuration

#### Directory where images reside. All workers should have reading access to this directory.

image_repository = '/afs/crc.nd.edu/group/ccl/software/runos'

#### Mapping 'Name of OS' to 'image'. 'image' is expected to be a singularity
#### image in the image_repository directory.

image_of = {
    'redhat6'  : 'rhel6.img',
    'redhat7'  : 'rhel7.img',
}

#### Directory where the workers reside. 
#### The hierarchy expected is worker_repository/ARCHITECTURE/OS/cctools/CCTOOLS_VERSION/bin/work_queue_worker
#### ARCHITECTURE will eventually be found automatically. Now it's fixed to x86_64
#### OS is a reguired command line argument (e.g., redhat7)
#### CCTOOLS_VERSION is set by the command line argument --worker-version (defaults to 'stable')

worker_repository = '/afs/crc.nd.edu/group/ccl/software'

###### END OF CONFIGURATION


def write_stdout(lefile, proc, unique_id, lelock):
    with proc.stdout:
        for line in iter(proc.stdout.readline,b''):
            lelock.acquire()
            try:
                logfile.write('[runos-{}] stdout: {}'.format(unique_id,line))
            finally:
                lelock.release()

def write_stderr(lefile, proc, unique_id, lelock):
    with proc.stderr:
        for line in iter(proc.stderr.readline,b''):
            lelock.acquire()
            try:
                logfile.write('[runos-{}] stderr: {}'.format(unique_id,line))
            finally:
                lelock.release()


def clean_and_remove(path):
    return shutil.rmtree(path)

def show_help():
    sys.stderr.write("""
    Usage:
        runos [--worker-version VERSION] [--debug-file OUTPUT] [--singularity SINGULARITY-EXEC] --os TARGET_OS --run-worker -- WORKER-ARGUMENTS ...

        or 

        runos [--worker-version VERSION] [--debug-file OUTPUT] [--singularity SINGULARITY-EXEC] --os TARGET_OS COMMAND_TO_RUN COMMAND_ARGUMENTS ...

        where TARGET_OS is one of: {}
    """.format(', '.join(image_of.keys())))

def parse_command_line_argumets(argv):
    try:
        opts, args_left = getopt.getopt(sys.argv[1:], '', ['os=','run-worker', 'worker-version=','debug-file=','singularity='])

        opts_dict = dict(opts)
        command_opts = args_left

        print(sys.argv)
        print(args_left)
        print(opts)

        if not ('--os' in opts_dict.keys()):
            sys.stderr.write("command line option '--os' is required")
            show_help()
            sys.exit(1)

        target           = opts_dict['--os']
        worker_version   = opts_dict.get('--worker-version', 'stable')
        debug_output     = opts_dict.get('--debug-file',  None)
        singularity_opt  = opts_dict.get('--singularity', None)
        run_worker       = True if '--run-worker' in opts_dict.keys() else False

        if run_worker is False and not command_opts:
            sys.stderr.write("Either COMMAND_TO_RUN or --run-worker are needed.")
            show_help()
            sys.exit(1)

        return (target, run_worker, command_opts, singularity_opt, worker_version, debug_output)

    except Exception:
        raise
        show_help()
        sys.exit(1)

def find_worker_executable(worker_repository, target, worker_version):
    worker_executable = os.path.join(worker_repository, 'x86_64', target, 'cctools', worker_version, 'bin', 'work_queue_worker')

    if not (os.path.isfile(worker_executable) and os.access(worker_executable, os.X_OK)):
        sys.stderr.write("could not find worker executable at '{}'\n".format(worker_executable))
        exit(1)

    return worker_executable


def find_executable(executable, paths = os.environ['PATH']):
    for path in paths.split(':'):
        candidate = os.path.join(path, executable)
        if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
            return candidate
    return None


def get_redhat_release():
    try:
        with open('/etc/redhat-release') as f:
            match = re.search('.*release (?P<major>[0-9])+.*', f.read())
            if match:
                return 'redhat' + match.groupdict()['major']
    except Exception:
        raise
        pass

    return 'unknown'


def find_sigularity_executable(path_from_opt):

    singularity = path_from_opt
    if singularity is None:
        singularity = find_executable('singularity', os.environ.get('PATH', '') + ':/usr/bin:/usr/local/bin') 

    if singularity is None or not (os.path.isfile(singularity) and os.access(singularity, os.X_OK)):
        sys.stderr.write("could not find a working singularity executable\n")
        return None

    return singularity


if __name__ == "__main__":

    target, worker_opts, run_worker, singularity_opt, worker_version, debug_output = parse_command_line_argumets(sys.argv)

    logfile = sys.stderr
    if(debug_output):
        logfile = open(debug_output, 'a+')

    # osused is the path to the image for target
    try:
        osused = os.path.join(image_repository, image_of[target])
    except KeyError:
        sys.stderr.write("could not find an image for target os '{}'\n".format(target))
        exit(1)

    # worker_executable is the path to the correct work_queue_worker
    worker_executable = find_worker_executable(worker_repository, target, worker_version)

    # singularity_executable is the absolute path to singularity
    singularity_executable = find_sigularity_executable(singularity_opt)

    # runos instance id to create tmp directory, label log lines, etc.
    unique_id = str(uuid.uuid4())[:8]

    #ensure singularity on computer
    run_native=False
    if singularity_executable is None:
        redhat_release = get_redhat_release()

        if redhat_release == target:
            run_native = True
        else:
            sys.stderr.write("singularity is not installed, and the host system '{}' does not match taget '{}'\n".format(redhat_release, target))
            exit(2)

    try:
        tmphome = "/tmp/runos_singularity_home-{}".format(unique_id)
        if not (os.path.isdir(tmphome)):
            os.mkdir(tmphome,0755)
    except Exception, e:
        sys.stderr.write("could not create temporary directory {}: {}".format(tmphome), e)
        sys.exit(3)

    try:
        shutil.copy(worker_executable, tmphome)
    except Exception, e:
        sys.stderr.write("could not copy worker executable {} to temporary directory {}: {}".format(worker_executable, tmphome), e)
        sys.exit(3)


    worker_cmdlst = [os.path.join(tmphome, 'work_queue_worker')] + worker_opts
    
    if run_native:
        proc = subprocess.Popen(' '.join(worker_cmdlst), shell=True)
        proc.wait()
        exitcode = proc.returncode
        clean_and_remove(tmphome)
        exit(exitcode)
    else:
        sing_cmd = [singularity_executable, "exec", "--home", "{}:/worker-home".format(tmphome), "--bind","/var:/var", osused, "sh", "-c", "'" + " ".join(worker_cmdlst) + "'"]

        logfile.write('[runos-{}]: {}\n'.format(unique_id,'STARTING'))
        logfile.write('[runos-{}] cmd: {}\n'.format(unique_id,' '.join(sing_cmd)))

        proc = subprocess.Popen(' '.join(sing_cmd),stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)  
        lelock = threading.Lock()
        out_t = threading.Thread(target = write_stdout, args=(logfile, proc, unique_id, lelock,))
        err_t = threading.Thread(target = write_stderr, args=(logfile, proc, unique_id, lelock,))
        out_t.start()
        err_t.start()
        out_t.join()
        err_t.join()
        proc.wait()
        exitcode = proc.returncode
        clean_and_remove(tmphome)
        logfile.write('[runos-{}] ret: {}\n'.format(unique_id,exitcode))
        logfile.close()
        exit(exitcode)  

#vim: set sts=4 sw=4 ts=4 expandtab ft=python:

