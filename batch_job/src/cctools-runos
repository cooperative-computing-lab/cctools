#! /usr/bin/env python

# Copyright (C) 2018- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

import distutils
import getopt
import json
import os
import platform
import re
import shlex
import shutil
import subprocess
import sys
import uuid

#### All the following variables are set by reading the configuration file cctools-runos.json

#### Directory where images reside. All workers should have reading access to this directory.
image_repository = None

#### Directory where the workers reside. 
#### The hierarchy expected is worker_repository/ARCHITECTURE/OS/cctools/CCTOOLS_VERSION/bin/work_queue_worker
#### ARCHITECTURE will eventually be found automatically. Now it's fixed to x86_64
#### OS is a reguired command line argument (e.g., redhat7)
#### CCTOOLS_VERSION is set by the command line argument --worker-version (defaults to 'stable')
worker_repository = None

#### Mapping 'Name of OS' to 'image'. 'image' is expected to be a singularity
#### image in the image_repository directory.
image_of = {}

####


#### Original contents of configuration file
conf_contents = None


def clean_and_remove(path):
    return shutil.rmtree(path)

def show_help():
    sys.stderr.write("""
    Usage:
        runos [--conf CONF] [--debug-file OUTPUT] [--singularity SINGULARITY-EXEC] --os TARGET_OS --worker-version VERSION --run-worker -- WORKER-ARGUMENTS ...

        or 

        runos [--conf CONF] [--debug-file OUTPUT] [--singularity SINGULARITY-EXEC] --os TARGET_OS COMMAND_TO_RUN COMMAND_ARGUMENTS ...
    """)

def parse_command_line_argumets(argv):
    try:
        opts, args_left = getopt.getopt(sys.argv[1:], '', ['os=', 'conf=', 'dump-conf', 'run-worker', 'worker-version=','debug-file=','singularity='])

        opts_dict = dict(opts)
        command_opts = args_left

        target          = opts_dict.get('--os', None)
        worker_version  = opts_dict.get('--worker-version', 'stable')
        debug_output    = opts_dict.get('--debug-file',  None)
        singularity_opt = opts_dict.get('--singularity', None)
        conf            = find_conf_file(opts_dict.get('--conf', None))
        run_worker      = True if '--run-worker' in opts_dict.keys() else False
        dump_conf       = True if '--dump-conf' in opts_dict.keys() else False

        if not dump_conf:
            if target is None:
                sys.stderr.write("command line option '--os' is required")
                show_help()
                sys.exit(1)

            if run_worker is False and not command_opts:
                sys.stderr.write("Either COMMAND_TO_RUN or --run-worker are needed.")
                show_help()
                sys.exit(1)

        return (target, conf, dump_conf, run_worker, command_opts, singularity_opt, worker_version, debug_output)

    except Exception:
        raise
        show_help()
        sys.exit(1)

def find_worker_executable(worker_repository, target, worker_version):
    worker_executable = os.path.join(worker_repository, 'x86_64', target, 'cctools', worker_version, 'bin', 'work_queue_worker')

    if not (os.path.isfile(worker_executable) and os.access(worker_executable, os.X_OK)):
        sys.stderr.write("could not find worker executable at '{}'\n".format(worker_executable))
        exit(1)

    return worker_executable

def find_conf_file(conf_path):
    base = os.path.dirname(os.path.abspath(__file__))

    if conf_path:
        return conf_path

    for location in [ '', '../etc/cctools', '../etc' ]:
        candidate = os.path.join(base, location, 'cctools-runos.json')

        if os.path.isfile(candidate):
            return candidate

    sys.stderr.write("could not find a configuration file\n")
    exit(1)


def read_configuration(conf_path):

    try:
        with open(conf_path) as f:
            raw = f.read()
            conf_dict = json.loads(raw)

            image_repository  = conf_dict['image-repository']
            worker_repository = conf_dict['worker-repository']
            image_of          = conf_dict['images']
            conf_contents     = raw

            return (image_repository, worker_repository, image_of, conf_contents)
    except KeyError as e:
        sys.stderr.write("configuration file {} does not have key {}".format(conf_path, e))
        exit(1)
    except Exception as e:
        sys.stderr.write("error reading configuration file {}: {}".format(conf_path, e))
        exit(1)


def find_executable(executable, paths = os.environ['PATH']):
    for path in paths.split(':'):
        candidate = os.path.join(path, executable)
        if os.path.isfile(candidate) and os.access(candidate, os.X_OK):
            return candidate
    return None


def get_redhat_release():
    try:
        with open('/etc/redhat-release') as f:
            match = re.search('.*release (?P<major>[0-9])+.*', f.read())
            if match:
                return 'redhat' + match.groupdict()['major']
    except Exception:
        raise
        pass

    return 'unknown'


def find_sigularity_executable(path_from_opt):

    singularity = path_from_opt
    if singularity is None:
        singularity = find_executable('singularity', os.environ.get('PATH', '') + ':/usr/bin:/usr/local/bin') 

    if singularity is None or not (os.path.isfile(singularity) and os.access(singularity, os.X_OK)):
        sys.stderr.write("could not find a working singularity executable\n")
        return None

    return singularity


if __name__ == "__main__":

    target, conf, dump_conf, run_worker, command_opts, singularity_opt, worker_version, debug_output = parse_command_line_argumets(sys.argv)

    image_repository, worker_repository, image_of, conf_contents = read_configuration(conf)

    if(dump_conf):
        sys.stdout.write(conf_contents)
        sys.exit(0)

    logfile = sys.stderr
    if(debug_output):
        logfile = open(debug_output, 'a+')


    # osused is the path to the image for target
    try:
        osused = os.path.join(image_repository, image_of[target])
    except KeyError:
        sys.stderr.write("could not find an image for target os '{}'\n".format(target))
        exit(1)

    # executable is the path to the correct work_queue_worker if --run-worker is given
    executable = None
    if run_worker:
        executable = find_worker_executable(worker_repository, target, worker_version)
    else:
        executable = command_opts.pop(0)


    # singularity_executable is the absolute path to singularity
    singularity_executable = find_sigularity_executable(singularity_opt)

    # runos instance id to create tmp directory, label log lines, etc.
    unique_id = str(uuid.uuid4())[:8]

    #ensure singularity on computer
    run_native=False
    if singularity_executable is None:
        redhat_release = get_redhat_release()

        if redhat_release == target:
            run_native = True
        else:
            sys.stderr.write("singularity is not installed, and the host system '{}' does not match taget '{}'\n".format(redhat_release, target))
            exit(2)

    try:
        tmphome = "/tmp/runos_singularity_home-{}".format(unique_id)
        if not (os.path.isdir(tmphome)):
            os.mkdir(tmphome, 0o755)
    except Exception as e:
        sys.stderr.write("could not create temporary directory {}: {}".format(tmphome), e)
        sys.exit(3)

    if run_worker:
        try:
            shutil.copy(executable, tmphome)
            executable = os.path.join(tmphome, os.path.basename(executable))   # execute with a path from inside singularity
        except Exception as e:
            sys.stderr.write("could not copy worker executable {} to temporary directory {}: {}".format(executable, tmphome), e)
            sys.exit(3)

    cmdlst  = [executable] + command_opts

    if run_native or True:
        logfile.write('[runos-{}]: STARTING with native execution\n'.format(unique_id))
    else:
        logfile.write('[runos-{}]: STARTING with singularity image {}\n'.format(unique_id,osused))
        sing_cmdlst = [singularity_executable, "exec", "--home", "{}:/worker-home".format(tmphome), osused]
        cmdlst = sing_cmdlst + cmdlst

    logfile.write('[runos-{}]: {}\n'.format(unique_id, cmdlst))

    exitcode = subprocess.call(cmdlst, stdout=logfile, stderr=subprocess.STDOUT)

    clean_and_remove(tmphome)
    logfile.write('[runos-{}] ret: {}\n'.format(unique_id,exitcode))
    logfile.close()

    exit(exitcode)  

#vim: set sts=4 sw=4 ts=4 expandtab ft=python:

