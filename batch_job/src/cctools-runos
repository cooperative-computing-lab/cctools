#! /usr/bin/env python

# Copyright (C) 2018- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

import sys
import os
import subprocess
import shlex
import uuid
import platform
import threading
import getopt

######## Configuration

#### Directory where images reside. All workers should have reading access to this directory.

image_repository = '/afs/crc.nd.edu/group/ccl/software/runos'

#### Mapping 'Name of OS' to 'image'. 'image' is expected to be a singularity
#### image in the image_repository directory.

image_of = {
    'redhat6'  : 'rhel6.img',
    'redhat7'  : 'rhel7.img',
}

#### Directory where the workers reside. 
#### The hierarchy expected is worker_repository/ARCHITECTURE/OS/cctools/CCTOOLS_VERSION/bin/work_queue_worker
#### ARCHITECTURE will eventually be found automatically. Now it's fixed to x86_64
#### OS is a reguired command line argument (e.g., redhat7)
#### CCTOOLS_VERSION is set by the command line argument --worker-version (defaults to 'stable')

worker_repository = '/afs/crc.nd.edu/group/ccl/software'

###### END OF CONFIGURATION





def write_stdout(lefile, proc, mid, lelock):
    with proc.stdout:
        for line in iter(proc.stdout.readline,b''):
            lelock.acquire()
            try:
                logfile.write('[runos-%d]out: %s\n'%(mid,line))
            finally:
                lelock.release()

def write_stderr(lefile, proc, mid, lelock):
    with proc.stderr:
        for line in iter(proc.stderr.readline,b''):
            lelock.acquire()
            try:
                logfile.write('[runos-%d]err: %s\n'%(mid,line))
            finally:
                lelock.release()



def clean_and_remove(path):
    allthings = os.listdir(path)
    for x in allthings:
        if os.path.isdir(x):
            clean_and_remove(x)
            os.rmdir(x)
        else:
            os.remove(x)
    return 1

def arr_to_str(arr):
    s = ""
    for x in arr:
        s += ("%s " % x)
    return s[:-1]

def convert(shlex_list):
    a = []
    for x in shlex_list:
        a.append(str(x))
    return a


def show_help():
    sys.stderr.write("""
    Usage:
        runos [--worker-version VERSION] [--debug-file OUTPUT] [--singularity SINGULARITY-EXEC] --os TARGET_OS --run-worker -- WORKER-ARGUMENTS ...

        or 

        runos [--worker-version VERSION] [--debug-file OUTPUT] [--singularity SINGULARITY-EXEC] --os TARGET_OS COMMAND_TO_RUN COMMAND_ARGUMENTS ...

        where TARGET_OS is one of: {}
    """.format(', '.join(image_of.keys())))

def parse_command_line_argumets(argv):
    try:
        opts, args_left = getopt.getopt(sys.argv[1:], '', ['os=','run-worker', 'worker-version=','debug-file=','singularity='])

        opts_dict = dict(opts)
        command_opts = args_left

        print(sys.argv)
        print(args_left)
        print(opts)

        if not ('--os' in opts_dict.keys()):
            sys.stderr.write("command line option '--os' is required")
            show_help()
            sys.exit(1)

        target           = opts_dict['--os']
        worker_version   = opts_dict.get('--worker-version', 'stable')
        debug_output     = opts_dict.get('--debug-file',  None)
        singularity_opt  = opts_dict.get('--singularity', None)
        run_worker       = True if '--run-worker' in opts_dict.keys() else False

        if run_worker is False and not command_opts:
            sys.stderr.write("Either COMMAND_TO_RUN or --run-worker are needed.")
            show_help()
            sys.exit(1)

        return (target, run_worker, command_opts, singularity_opt, worker_version, debug_output)

    except Exception:
        raise
        show_help()
        sys.exit(1)



if __name__ == "__main__":

    target, worker_opts, run_worker, singularity_opt, worker_version, debug_output = parse_command_line_argumets(sys.argv)

    logfile = sys.stderr
    if(debug_output):
        logfile = open(debug_output, 'a+')

    switch=True

    # osused is the path to the image for target
    try:
        osused = os.path.join(image_repository, image_of[target])
    except KeyError:
        sys.stderr.write("could not find an image for target os '{}'\n".format(target))
        exit(1)
    
    #ensure singularity on computer
    run_native=False
    try:
        proc = subprocess.Popen('~condor/software/config/get_system_info.sh',stdout=subprocess.PIPE,shell=True)
        (out, err) = proc.communicate()
        base = str(platform.dist())
        if not "has_singularity = true" in out: #no singularity
            if ('redhat' in base and '6' in base) and ('rhel6' == target or 'osg_el6' == target):
                run_native = True
            elif ('redhat' in base and '7' in base) and ('rhel7' == target):
                run_native = True
            else:
                sys.stderr.write("The System doesn't have Singularity Installed, and the target is unrecognized!\n")
                exit(17)
        #can assume singularity
        proc2 = subprocess.Popen('singularity exec %s python -c "import platform; print platform.dist()"'%osused,stdout=subprocess.PIPE,shell=True)
        (imgbase,err2) = proc2.communicate() 
        if   ('redhat' in base and '6' in base) and (('redhat' in imgbase or 'centos' in imgbase) and '6' in imgbase):
            run_native = True
        elif ('redhat' in base and '7' in base) and (('redhat' in imgbase or 'centos' in imgbase) and '7' in imgbase):
            run_native = True
    except Exception, e:
        print e
        exit(88)
    
    #calling process
    mid = uuid.uuid4()
    if run_native and not run_native:
        exitcode = subprocess.call(cmd)
        exit(exitcode)
    else:
        tmphome = "/tmp/runos_singularity_home-%d"%mid
        if not (os.path.isdir(tmphome)):
            os.mkdir(tmphome,0777)

        cmdwrap = "'cd /disk; %s'" % (arr_to_str(cmd))
        #newcmd  = ["exec","--bind","%s:/disk"%os.getcwd(),"--home","%s:%s"%(tmphome,tmphome),"--bind","/var:/var","--bind","/afs/crc.nd.edu/group/ccl/software:/cclsoftware",osused,"sh","-c",cmdwrap]
        newcmd  = ["exec","--bind","%s:/disk"%os.getcwd(),"--home","%s:%s"%(tmphome,tmphome),"--bind","/var:/var","--bind","/afs/:/afs",osused,"sh","-c",cmdwrap]

        if os.path.isfile("/usr/local/bin/singularity"):
            newcmd.insert(0, "/usr/local/bin/singularity")
        elif os.path.isfile("/usr/bin/singularity"):
            newcmd.insert(0, "/usr/bin/singularity")
        else:
            newcmd.insert(0, "singularity")
        #exitcode = subprocess.call(cmd)
        #proc = subprocess.Popen(' '.join(newcmd),stdout=subprocess.STDOUT,stderr=subprocess.STDOUT,shell=True)
        if switch == False:
            proc = subprocess.Popen(' '.join(newcmd),shell=True)
            proc.wait()
            exitcode = proc.returncode
            clean_and_remove(tmphome)
            #logfile.write('[runos-%d]ret: %i\n'%(mid,exitcode))
            #logfile.close()
            exit(exitcode)
        else:   
            logfile.write('[runos-%d]: %s\n'%(mid,'STARTING'))
            logfile.write('[runos-%d]cmd: %s\n'%(mid,' '.join(newcmd)))
            proc = subprocess.Popen(' '.join(newcmd),stdout=subprocess.PIPE,stderr=subprocess.PIPE,shell=True)  
            lelock = threading.Lock()
            out_t = threading.Thread(target = write_stdout, args=(logfile, proc, mid, lelock,))
            err_t = threading.Thread(target = write_stderr, args=(logfile, proc, mid, lelock,))
            out_t.start()
            err_t.start()
            out_t.join()
            err_t.join()
            #with proc.stdout:
            #   for line in iter(proc.stdout.readline,b''):
            #       print(line)
            #       logfile.write('[runos-%d]out: %s\n'%(mid,line))
            #(out) = proc.communicate()
            proc.wait()
            exitcode = proc.returncode
            clean_and_remove(tmphome)
            #print(out)
            #print(err)
            #logfile.write('[runos-%d]out: %s\n'%(mid,out))
            #logfile.write('[runos-%d]err: %s\n'%(mid,err))
            logfile.write('[runos-%d]ret: %i\n'%(mid,exitcode))
            logfile.close()
            exit(exitcode)  

#vim: set sts=4 sw=4 ts=4 expandtab ft=python:

