# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.2
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _chirp
else:
    import _chirp

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


D_INFO = _chirp.D_INFO
D_FATAL = _chirp.D_FATAL
D_ERROR = _chirp.D_ERROR
D_NOTICE = _chirp.D_NOTICE
D_DEBUG = _chirp.D_DEBUG
D_SYSCALL = _chirp.D_SYSCALL
D_CHANNEL = _chirp.D_CHANNEL
D_PROCESS = _chirp.D_PROCESS
D_RESOLVE = _chirp.D_RESOLVE
D_LIBCALL = _chirp.D_LIBCALL
D_LOCAL = _chirp.D_LOCAL
D_DNS = _chirp.D_DNS
D_TCP = _chirp.D_TCP
D_AUTH = _chirp.D_AUTH
D_IRODS = _chirp.D_IRODS
D_CVMFS = _chirp.D_CVMFS
D_HTTP = _chirp.D_HTTP
D_FTP = _chirp.D_FTP
D_NEST = _chirp.D_NEST
D_GROW = _chirp.D_GROW
D_CHIRP = _chirp.D_CHIRP
D_DCAP = _chirp.D_DCAP
D_RFIO = _chirp.D_RFIO
D_GLITE = _chirp.D_GLITE
D_MULTI = _chirp.D_MULTI
D_PSTREE = _chirp.D_PSTREE
D_ALLOC = _chirp.D_ALLOC
D_LFC = _chirp.D_LFC
D_GFAL = _chirp.D_GFAL
D_SUMMARY = _chirp.D_SUMMARY
D_LOGIN = _chirp.D_LOGIN
D_CACHE = _chirp.D_CACHE
D_POLL = _chirp.D_POLL
D_HDFS = _chirp.D_HDFS
D_WQ = _chirp.D_WQ
D_BXGRID = _chirp.D_BXGRID
D_USER = _chirp.D_USER
D_XROOTD = _chirp.D_XROOTD
D_MPI = _chirp.D_MPI
D_BATCH = _chirp.D_BATCH
D_RMON = _chirp.D_RMON
D_MAKEFLOW_RUN = _chirp.D_MAKEFLOW_RUN
D_MAKEFLOW_LEXER = _chirp.D_MAKEFLOW_LEXER
D_MAKEFLOW_PARSER = _chirp.D_MAKEFLOW_PARSER
D_MAKEFLOW_ALLOC = _chirp.D_MAKEFLOW_ALLOC
D_CONFUGA = _chirp.D_CONFUGA
D_JX = _chirp.D_JX
D_MAKEFLOW_HOOK = _chirp.D_MAKEFLOW_HOOK
D_EXT = _chirp.D_EXT
D_VINE = _chirp.D_VINE
D_TLQ = _chirp.D_TLQ
D_SSL = _chirp.D_SSL
D_REMOTE = _chirp.D_REMOTE
D_MAKEFLOW = _chirp.D_MAKEFLOW
D_ALL = _chirp.D_ALL

def cctools_debug(*args) -> "void":
    return _chirp.cctools_debug(*args)

def cctools_warn(*args) -> "void":
    return _chirp.cctools_warn(*args)

def cctools_fatal(*args) -> "void":
    return _chirp.cctools_fatal(*args)

def cctools_notice(*args) -> "void":
    return _chirp.cctools_notice(*args)

def cctools_debug_config(name: "char const *") -> "void":
    return _chirp.cctools_debug_config(name)

def cctools_debug_config_file(file: "char const *") -> "void":
    return _chirp.cctools_debug_config_file(file)

def debug_config_file_e(file: "char const *") -> "int":
    return _chirp.debug_config_file_e(file)

def cctools_debug_config_file_size(size: "off_t") -> "void":
    return _chirp.cctools_debug_config_file_size(size)

def cctools_debug_config_fatal(callback: "void (*)(void)") -> "void":
    return _chirp.cctools_debug_config_fatal(callback)

def cctools_debug_config_getpid(getpidf: "pid_t (*)(void)") -> "void":
    return _chirp.cctools_debug_config_getpid(getpidf)

def cctools_debug_flags_set(flagname: "char const *") -> "int":
    return _chirp.cctools_debug_flags_set(flagname)

def cctools_debug_flags_print(stream: "FILE *") -> "void":
    return _chirp.cctools_debug_flags_print(stream)

def cctools_debug_flags_clear() -> "int64_t":
    return _chirp.cctools_debug_flags_clear()

def cctools_debug_set_flag_name(flag: "int64_t", name: "char const *") -> "void":
    return _chirp.cctools_debug_set_flag_name(flag, name)

def cctools_debug_flags_restore(flags: "int64_t") -> "void":
    return _chirp.cctools_debug_flags_restore(flags)

def cctools_debug_rename(suffix: "char const *") -> "void":
    return _chirp.cctools_debug_rename(suffix)

def debug_reopen() -> "void":
    return _chirp.debug_reopen()

def timestamp_get() -> "timestamp_t":
    return _chirp.timestamp_get()

def timestamp_fmt(buf: "char *", size: "size_t", fmt: "char const *", ts: "timestamp_t") -> "int":
    return _chirp.timestamp_fmt(buf, size, fmt, ts)

def timestamp_sleep(interval: "timestamp_t") -> "void":
    return _chirp.timestamp_sleep(interval)

def timestamp_file(file: "char const *") -> "time_t":
    return _chirp.timestamp_file(file)

def auth_register_byname(name: "char const *") -> "int":
    return _chirp.auth_register_byname(name)

def auth_register_all() -> "int":
    return _chirp.auth_register_all()

def auth_ticket_register() -> "int":
    return _chirp.auth_ticket_register()

def auth_ticket_server_callback(sc: "auth_ticket_server_callback_t") -> "void":
    return _chirp.auth_ticket_server_callback(sc)

def auth_ticket_load(tickets: "char const *") -> "void":
    return _chirp.auth_ticket_load(tickets)

def chirp_reli_open(host: "char const *", path: "char const *", flags: "int64_t", mode: "int64_t", stoptime: "time_t") -> "struct chirp_file *":
    return _chirp.chirp_reli_open(host, path, flags, mode, stoptime)

def chirp_reli_close(file: "struct chirp_file *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_close(file, stoptime)

def chirp_reli_pread(file: "struct chirp_file *", buffer: "void *", length: "int64_t", offset: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_pread(file, buffer, length, offset, stoptime)

def chirp_reli_pwrite(file: "struct chirp_file *", buffer: "void const *", length: "int64_t", offset: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_pwrite(file, buffer, length, offset, stoptime)

def chirp_reli_pread_unbuffered(file: "struct chirp_file *", buffer: "void *", length: "int64_t", offset: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_pread_unbuffered(file, buffer, length, offset, stoptime)

def chirp_reli_pwrite_unbuffered(file: "struct chirp_file *", buffer: "void const *", length: "int64_t", offset: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_pwrite_unbuffered(file, buffer, length, offset, stoptime)

def chirp_reli_sread(file: "struct chirp_file *", buffer: "void *", length: "int64_t", stride_length: "int64_t", stride_skip: "int64_t", offset: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_sread(file, buffer, length, stride_length, stride_skip, offset, stoptime)

def chirp_reli_swrite(file: "struct chirp_file *", buffer: "void const *", length: "int64_t", stride_length: "int64_t", stride_skip: "int64_t", offset: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_swrite(file, buffer, length, stride_length, stride_skip, offset, stoptime)

def chirp_reli_fstat(file: "struct chirp_file *", info: "chirp_stat", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fstat(file, info, stoptime)

def chirp_reli_fstatfs(file: "struct chirp_file *", info: "chirp_statfs", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fstatfs(file, info, stoptime)

def chirp_reli_fchown(file: "struct chirp_file *", uid: "int64_t", gid: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fchown(file, uid, gid, stoptime)

def chirp_reli_fchmod(file: "struct chirp_file *", mode: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fchmod(file, mode, stoptime)

def chirp_reli_ftruncate(file: "struct chirp_file *", length: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ftruncate(file, length, stoptime)

def chirp_reli_flush(file: "struct chirp_file *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_flush(file, stoptime)

def chirp_reli_fsync(file: "struct chirp_file *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fsync(file, stoptime)

def chirp_reli_getfile(host: "char const *", path: "char const *", stream: "FILE *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_getfile(host, path, stream, stoptime)

def chirp_reli_getfile_buffer(host: "char const *", path: "char const *", buffer: "char **", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_getfile_buffer(host, path, buffer, stoptime)

def chirp_reli_putfile(host: "char const *", path: "char const *", stream: "FILE *", mode: "int64_t", length: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_putfile(host, path, stream, mode, length, stoptime)

def chirp_reli_putfile_buffer(host: "char const *", path: "char const *", buffer: "void const *", mode: "int64_t", length: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_putfile_buffer(host, path, buffer, mode, length, stoptime)

def chirp_reli_opensearch(host: "char const *", paths: "char const *", pattern: "char const *", flags: "int", stoptime: "time_t") -> "CHIRP_SEARCH *":
    return _chirp.chirp_reli_opensearch(host, paths, pattern, flags, stoptime)

def chirp_reli_getlongdir(host: "char const *", path: "char const *", callback: "chirp_longdir_t", arg: "void *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_getlongdir(host, path, callback, arg, stoptime)

def chirp_reli_getdir(host: "char const *", path: "char const *", callback: "chirp_dir_t", arg: "void *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_getdir(host, path, callback, arg, stoptime)

def chirp_reli_opendir(host: "char const *", path: "char const *", stoptime: "time_t") -> "struct chirp_dir *":
    return _chirp.chirp_reli_opendir(host, path, stoptime)

def chirp_reli_readdir(dir: "struct chirp_dir *") -> "struct chirp_dirent *":
    return _chirp.chirp_reli_readdir(dir)

def chirp_reli_closedir(dir: "struct chirp_dir *") -> "void":
    return _chirp.chirp_reli_closedir(dir)

def chirp_reli_ticket_create(host: "char const *", name: "char [CHIRP_PATH_MAX]", bits: "unsigned int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ticket_create(host, name, bits, stoptime)

def chirp_reli_ticket_register(host: "char const *", name: "char const *", subject: "char const *", duration: "time_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ticket_register(host, name, subject, duration, stoptime)

def chirp_reli_ticket_delete(host: "char const *", name: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ticket_delete(host, name, stoptime)

def chirp_reli_ticket_list(host: "char const *", subject: "char const *", list: "char ***", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ticket_list(host, subject, list, stoptime)

def chirp_reli_ticket_get(host: "char const *", name: "char const *", subject: "char **", ticket: "char **", duration: "time_t *", rights: "char ***", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ticket_get(host, name, subject, ticket, duration, rights, stoptime)

def chirp_reli_ticket_modify(host: "char const *", name: "char const *", path: "char const *", aclmask: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_ticket_modify(host, name, path, aclmask, stoptime)

def chirp_reli_getacl(host: "char const *", path: "char const *", callback: "chirp_dir_t", arg: "void *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_getacl(host, path, callback, arg, stoptime)

def chirp_reli_setacl(host: "char const *", path: "char const *", subject: "char const *", rights: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_setacl(host, path, subject, rights, stoptime)

def chirp_reli_resetacl(host: "char const *", path: "char const *", rights: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_resetacl(host, path, rights, stoptime)

def chirp_reli_locate(host: "char const *", path: "char const *", callback: "chirp_loc_t", arg: "void *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_locate(host, path, callback, arg, stoptime)

def chirp_reli_whoami(host: "char const *", subject: "char *", length: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_whoami(host, subject, length, stoptime)

def chirp_reli_whoareyou(host: "char const *", rhost: "char const *", subject: "char *", length: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_whoareyou(host, rhost, subject, length, stoptime)

def chirp_reli_unlink(host: "char const *", path: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_unlink(host, path, stoptime)

def chirp_reli_rename(host: "char const *", path: "char const *", newpath: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_rename(host, path, newpath, stoptime)

def chirp_reli_link(host: "char const *", path: "char const *", newpath: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_link(host, path, newpath, stoptime)

def chirp_reli_symlink(host: "char const *", path: "char const *", newpath: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_symlink(host, path, newpath, stoptime)

def chirp_reli_readlink(host: "char const *", path: "char const *", buf: "char *", length: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_readlink(host, path, buf, length, stoptime)

def chirp_reli_mkdir(host: "char const *", path: "char const *", mode: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_mkdir(host, path, mode, stoptime)

def chirp_reli_mkdir_recursive(host: "char const *", path: "char const *", mode: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_mkdir_recursive(host, path, mode, stoptime)

def chirp_reli_rmdir(host: "char const *", path: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_rmdir(host, path, stoptime)

def chirp_reli_rmall(host: "char const *", path: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_rmall(host, path, stoptime)

def chirp_reli_stat(host: "char const *", path: "char const *", info: "chirp_stat", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_stat(host, path, info, stoptime)

def chirp_reli_lstat(host: "char const *", path: "char const *", info: "chirp_stat", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_lstat(host, path, info, stoptime)

def chirp_reli_statfs(host: "char const *", path: "char const *", info: "chirp_statfs", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_statfs(host, path, info, stoptime)

def chirp_reli_access(host: "char const *", path: "char const *", flags: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_access(host, path, flags, stoptime)

def chirp_reli_chmod(host: "char const *", path: "char const *", mode: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_chmod(host, path, mode, stoptime)

def chirp_reli_chown(host: "char const *", path: "char const *", uid: "int64_t", gid: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_chown(host, path, uid, gid, stoptime)

def chirp_reli_lchown(host: "char const *", path: "char const *", uid: "int64_t", gid: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_lchown(host, path, uid, gid, stoptime)

def chirp_reli_truncate(host: "char const *", path: "char const *", length: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_truncate(host, path, length, stoptime)

def chirp_reli_utime(host: "char const *", path: "char const *", actime: "time_t", modtime: "time_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_utime(host, path, actime, modtime, stoptime)

def chirp_reli_hash(host: "char const *", path: "char const *", algorithm: "char const *", digest: "unsigned char [CHIRP_DIGEST_MAX]", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_hash(host, path, algorithm, digest, stoptime)

def chirp_reli_md5(host: "char const *", path: "char const *", digest: "unsigned char [CHIRP_DIGEST_MAX]", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_md5(host, path, digest, stoptime)

def chirp_reli_setrep(host: "char const *", path: "char const *", nreps: "int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_setrep(host, path, nreps, stoptime)

def chirp_reli_getxattr(host: "char const *", path: "char const *", name: "char const *", data: "void *", size: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_getxattr(host, path, name, data, size, stoptime)

def chirp_reli_fgetxattr(file: "struct chirp_file *", name: "char const *", data: "void *", size: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fgetxattr(file, name, data, size, stoptime)

def chirp_reli_lgetxattr(host: "char const *", path: "char const *", name: "char const *", data: "void *", size: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_lgetxattr(host, path, name, data, size, stoptime)

def chirp_reli_listxattr(host: "char const *", path: "char const *", list: "char *", size: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_listxattr(host, path, list, size, stoptime)

def chirp_reli_flistxattr(file: "struct chirp_file *", list: "char *", size: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_flistxattr(file, list, size, stoptime)

def chirp_reli_llistxattr(host: "char const *", path: "char const *", list: "char *", size: "size_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_llistxattr(host, path, list, size, stoptime)

def chirp_reli_setxattr(host: "char const *", path: "char const *", name: "char const *", data: "void const *", size: "size_t", flags: "int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_setxattr(host, path, name, data, size, flags, stoptime)

def chirp_reli_fsetxattr(file: "struct chirp_file *", name: "char const *", data: "void const *", size: "size_t", flags: "int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fsetxattr(file, name, data, size, flags, stoptime)

def chirp_reli_lsetxattr(host: "char const *", path: "char const *", name: "char const *", data: "void const *", size: "size_t", flags: "int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_lsetxattr(host, path, name, data, size, flags, stoptime)

def chirp_reli_removexattr(host: "char const *", path: "char const *", name: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_removexattr(host, path, name, stoptime)

def chirp_reli_fremovexattr(file: "struct chirp_file *", name: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_fremovexattr(file, name, stoptime)

def chirp_reli_lremovexattr(host: "char const *", path: "char const *", name: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_lremovexattr(host, path, name, stoptime)

def chirp_reli_job_create(host: "char const *", json: "char const *", id: "chirp_jobid_t *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_job_create(host, json, id, stoptime)

def chirp_reli_job_commit(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_job_commit(host, json, stoptime)

def chirp_reli_job_kill(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_job_kill(host, json, stoptime)

def chirp_reli_job_status(host: "char const *", json: "char const *", status: "char **", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_job_status(host, json, status, stoptime)

def chirp_reli_job_wait(host: "char const *", id: "chirp_jobid_t", timeout: "int64_t", status: "char **", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_job_wait(host, id, timeout, status, stoptime)

def chirp_reli_job_reap(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_job_reap(host, json, stoptime)

def chirp_reli_remote_debug(host: "char const *", flag: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_remote_debug(host, flag, stoptime)

def chirp_reli_localpath(host: "char const *", path: "char const *", localpath: "char *", length: "int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_localpath(host, path, localpath, length, stoptime)

def chirp_reli_audit(host: "char const *", path: "char const *", list: "struct chirp_audit **", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_audit(host, path, list, stoptime)

def chirp_reli_thirdput(host: "char const *", path: "char const *", thirdhost: "char const *", thirdpath: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_thirdput(host, path, thirdhost, thirdpath, stoptime)

def chirp_reli_mkalloc(host: "char const *", path: "char const *", size: "int64_t", mode: "int64_t", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_mkalloc(host, path, size, mode, stoptime)

def chirp_reli_lsalloc(host: "char const *", path: "char const *", allocpath: "char *", total: "int64_t *", inuse: "int64_t *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_lsalloc(host, path, allocpath, total, inuse, stoptime)

def chirp_reli_bulkio(list: "chirp_bulkio", count: "int", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_reli_bulkio(list, count, stoptime)

def chirp_reli_blocksize_get() -> "int64_t":
    return _chirp.chirp_reli_blocksize_get()

def chirp_reli_blocksize_set(bs: "int64_t") -> "void":
    return _chirp.chirp_reli_blocksize_set(bs)

def chirp_reli_cleanup_before_fork() -> "void":
    return _chirp.chirp_reli_cleanup_before_fork()

def chirp_reli_disconnect(host: "char const *") -> "void":
    return _chirp.chirp_reli_disconnect(host)

def chirp_recursive_put(hostport: "char const *", sourcepath: "char const *", targetpath: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_recursive_put(hostport, sourcepath, targetpath, stoptime)

def chirp_recursive_get(hostport: "char const *", sourcepath: "char const *", targetpath: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_recursive_get(hostport, sourcepath, targetpath, stoptime)
class chirp_stat(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    cst_dev = property(_chirp.chirp_stat_cst_dev_get, _chirp.chirp_stat_cst_dev_set)
    cst_ino = property(_chirp.chirp_stat_cst_ino_get, _chirp.chirp_stat_cst_ino_set)
    cst_mode = property(_chirp.chirp_stat_cst_mode_get, _chirp.chirp_stat_cst_mode_set)
    cst_nlink = property(_chirp.chirp_stat_cst_nlink_get, _chirp.chirp_stat_cst_nlink_set)
    cst_uid = property(_chirp.chirp_stat_cst_uid_get, _chirp.chirp_stat_cst_uid_set)
    cst_gid = property(_chirp.chirp_stat_cst_gid_get, _chirp.chirp_stat_cst_gid_set)
    cst_rdev = property(_chirp.chirp_stat_cst_rdev_get, _chirp.chirp_stat_cst_rdev_set)
    cst_size = property(_chirp.chirp_stat_cst_size_get, _chirp.chirp_stat_cst_size_set)
    cst_blksize = property(_chirp.chirp_stat_cst_blksize_get, _chirp.chirp_stat_cst_blksize_set)
    cst_blocks = property(_chirp.chirp_stat_cst_blocks_get, _chirp.chirp_stat_cst_blocks_set)
    cst_atime = property(_chirp.chirp_stat_cst_atime_get, _chirp.chirp_stat_cst_atime_set)
    cst_mtime = property(_chirp.chirp_stat_cst_mtime_get, _chirp.chirp_stat_cst_mtime_set)
    cst_ctime = property(_chirp.chirp_stat_cst_ctime_get, _chirp.chirp_stat_cst_ctime_set)

    def __init__(self):
        _chirp.chirp_stat_swiginit(self, _chirp.new_chirp_stat())
    __swig_destroy__ = _chirp.delete_chirp_stat

# Register chirp_stat in _chirp:
_chirp.chirp_stat_swigregister(chirp_stat)

class chirp_statfs(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    f_type = property(_chirp.chirp_statfs_f_type_get, _chirp.chirp_statfs_f_type_set)
    f_blocks = property(_chirp.chirp_statfs_f_blocks_get, _chirp.chirp_statfs_f_blocks_set)
    f_bavail = property(_chirp.chirp_statfs_f_bavail_get, _chirp.chirp_statfs_f_bavail_set)
    f_bsize = property(_chirp.chirp_statfs_f_bsize_get, _chirp.chirp_statfs_f_bsize_set)
    f_bfree = property(_chirp.chirp_statfs_f_bfree_get, _chirp.chirp_statfs_f_bfree_set)
    f_files = property(_chirp.chirp_statfs_f_files_get, _chirp.chirp_statfs_f_files_set)
    f_ffree = property(_chirp.chirp_statfs_f_ffree_get, _chirp.chirp_statfs_f_ffree_set)

    def __init__(self):
        _chirp.chirp_statfs_swiginit(self, _chirp.new_chirp_statfs())
    __swig_destroy__ = _chirp.delete_chirp_statfs

# Register chirp_statfs in _chirp:
_chirp.chirp_statfs_swigregister(chirp_statfs)

class chirp_dirent(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_chirp.chirp_dirent_name_get, _chirp.chirp_dirent_name_set)
    lstatus = property(_chirp.chirp_dirent_lstatus_get, _chirp.chirp_dirent_lstatus_set)
    info = property(_chirp.chirp_dirent_info_get, _chirp.chirp_dirent_info_set)
    next_entry = property(_chirp.chirp_dirent_next_entry_get, _chirp.chirp_dirent_next_entry_set)

    def __init__(self):
        _chirp.chirp_dirent_swiginit(self, _chirp.new_chirp_dirent())
    __swig_destroy__ = _chirp.delete_chirp_dirent

# Register chirp_dirent in _chirp:
_chirp.chirp_dirent_swigregister(chirp_dirent)

class chirp_searchent(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    path = property(_chirp.chirp_searchent_path_get, _chirp.chirp_searchent_path_set)
    info = property(_chirp.chirp_searchent_info_get, _chirp.chirp_searchent_info_set)
    errsource = property(_chirp.chirp_searchent_errsource_get, _chirp.chirp_searchent_errsource_set)
    err = property(_chirp.chirp_searchent_err_get, _chirp.chirp_searchent_err_set)

    def __init__(self):
        _chirp.chirp_searchent_swiginit(self, _chirp.new_chirp_searchent())
    __swig_destroy__ = _chirp.delete_chirp_searchent

# Register chirp_searchent in _chirp:
_chirp.chirp_searchent_swigregister(chirp_searchent)

class chirp_searchstream(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    entry = property(_chirp.chirp_searchstream_entry_get, _chirp.chirp_searchstream_entry_set)
    current = property(_chirp.chirp_searchstream_current_get, _chirp.chirp_searchstream_current_set)
    B = property(_chirp.chirp_searchstream_B_get, _chirp.chirp_searchstream_B_set)

    def __init__(self):
        _chirp.chirp_searchstream_swiginit(self, _chirp.new_chirp_searchstream())
    __swig_destroy__ = _chirp.delete_chirp_searchstream

# Register chirp_searchstream in _chirp:
_chirp.chirp_searchstream_swigregister(chirp_searchstream)

CHIRP_SEARCH_STOPATFIRST = _chirp.CHIRP_SEARCH_STOPATFIRST
CHIRP_SEARCH_METADATA = _chirp.CHIRP_SEARCH_METADATA
CHIRP_SEARCH_INCLUDEROOT = _chirp.CHIRP_SEARCH_INCLUDEROOT
CHIRP_SEARCH_PERIOD = _chirp.CHIRP_SEARCH_PERIOD
CHIRP_SEARCH_R_OK = _chirp.CHIRP_SEARCH_R_OK
CHIRP_SEARCH_W_OK = _chirp.CHIRP_SEARCH_W_OK
CHIRP_SEARCH_X_OK = _chirp.CHIRP_SEARCH_X_OK
CHIRP_SEARCH_ERR_OPEN = _chirp.CHIRP_SEARCH_ERR_OPEN
CHIRP_SEARCH_ERR_READ = _chirp.CHIRP_SEARCH_ERR_READ
CHIRP_SEARCH_ERR_CLOSE = _chirp.CHIRP_SEARCH_ERR_CLOSE
CHIRP_SEARCH_ERR_STAT = _chirp.CHIRP_SEARCH_ERR_STAT
CHIRP_SEARCH_DELIMITER = _chirp.CHIRP_SEARCH_DELIMITER
CHIRP_SEARCH_DEPTH_MAX = _chirp.CHIRP_SEARCH_DEPTH_MAX
CHIRP_BULKIO_PREAD = _chirp.CHIRP_BULKIO_PREAD
CHIRP_BULKIO_PWRITE = _chirp.CHIRP_BULKIO_PWRITE
CHIRP_BULKIO_SREAD = _chirp.CHIRP_BULKIO_SREAD
CHIRP_BULKIO_SWRITE = _chirp.CHIRP_BULKIO_SWRITE
CHIRP_BULKIO_FSTAT = _chirp.CHIRP_BULKIO_FSTAT
CHIRP_BULKIO_FSYNC = _chirp.CHIRP_BULKIO_FSYNC
class chirp_bulkio(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    type_io = property(_chirp.chirp_bulkio_type_io_get, _chirp.chirp_bulkio_type_io_set)
    file = property(_chirp.chirp_bulkio_file_get, _chirp.chirp_bulkio_file_set)
    info = property(_chirp.chirp_bulkio_info_get, _chirp.chirp_bulkio_info_set)
    buffer = property(_chirp.chirp_bulkio_buffer_get, _chirp.chirp_bulkio_buffer_set)
    length = property(_chirp.chirp_bulkio_length_get, _chirp.chirp_bulkio_length_set)
    stride_length = property(_chirp.chirp_bulkio_stride_length_get, _chirp.chirp_bulkio_stride_length_set)
    stride_skip = property(_chirp.chirp_bulkio_stride_skip_get, _chirp.chirp_bulkio_stride_skip_set)
    offset = property(_chirp.chirp_bulkio_offset_get, _chirp.chirp_bulkio_offset_set)
    result = property(_chirp.chirp_bulkio_result_get, _chirp.chirp_bulkio_result_set)
    errnum = property(_chirp.chirp_bulkio_errnum_get, _chirp.chirp_bulkio_errnum_set)

    def __init__(self):
        _chirp.chirp_bulkio_swiginit(self, _chirp.new_chirp_bulkio())
    __swig_destroy__ = _chirp.delete_chirp_bulkio

# Register chirp_bulkio in _chirp:
_chirp.chirp_bulkio_swigregister(chirp_bulkio)

class chirp_audit(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    name = property(_chirp.chirp_audit_name_get, _chirp.chirp_audit_name_set)
    nfiles = property(_chirp.chirp_audit_nfiles_get, _chirp.chirp_audit_nfiles_set)
    ndirs = property(_chirp.chirp_audit_ndirs_get, _chirp.chirp_audit_ndirs_set)
    nbytes = property(_chirp.chirp_audit_nbytes_get, _chirp.chirp_audit_nbytes_set)

    def __init__(self):
        _chirp.chirp_audit_swiginit(self, _chirp.new_chirp_audit())
    __swig_destroy__ = _chirp.delete_chirp_audit

# Register chirp_audit in _chirp:
_chirp.chirp_audit_swigregister(chirp_audit)

CHIRP_DIGEST_MAX = _chirp.CHIRP_DIGEST_MAX

def chirp_wrap_stat(hostname: "char const *", path: "char const *", stoptime: "time_t") -> "struct chirp_stat *":
    return _chirp.chirp_wrap_stat(hostname, path, stoptime)

def chirp_wrap_listacl(hostname: "char const *", path: "char const *", stoptime: "time_t") -> "char *":
    return _chirp.chirp_wrap_listacl(hostname, path, stoptime)

def chirp_wrap_whoami(hostname: "char const *", stoptime: "time_t") -> "char *":
    return _chirp.chirp_wrap_whoami(hostname, stoptime)

def chirp_wrap_hash(hostname: "char const *", path: "char const *", algorithm: "char const *", stoptime: "time_t") -> "char *":
    return _chirp.chirp_wrap_hash(hostname, path, algorithm, stoptime)

def chirp_wrap_job_create(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_wrap_job_create(host, json, stoptime)

def chirp_wrap_job_commit(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_wrap_job_commit(host, json, stoptime)

def chirp_wrap_job_kill(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_wrap_job_kill(host, json, stoptime)

def chirp_wrap_job_reap(host: "char const *", json: "char const *", stoptime: "time_t") -> "int64_t":
    return _chirp.chirp_wrap_job_reap(host, json, stoptime)

def chirp_wrap_job_status(host: "char const *", json: "char const *", stoptime: "time_t") -> "char *":
    return _chirp.chirp_wrap_job_status(host, json, stoptime)

def chirp_wrap_job_wait(host: "char const *", id: "chirp_jobid_t", timeout: "int64_t", stoptime: "time_t") -> "char *":
    return _chirp.chirp_wrap_job_wait(host, id, timeout, stoptime)


## @package chirp
#
# Python Chirp bindings.
#
# The objects and methods provided by this package correspond to the native
# C API in @ref chirp_reli.h and chirp_swig_wrap.h
#
# The SWIG-based Python bindings provide a higher-level interface that
# revolves around:
#
# - @ref chirp.Client
# - @ref chirp.Stat
import os
import time
import json

##
# \class chirp.Client
# Python Client object
#
# This class is used to create a chirp client
class Client(object):

    ##
    # Create a new chirp client
    #
    # @param self              Reference to the current task object.
    # @param hostport          The host:port of the server.
    # @param timeout           The time to wait for a server response on every request.
    # @param authentication    A list of prefered authentications. E.g., ['tickets', 'unix']
    # @param tickets           A list of ticket filenames.
    # @param debug             Generate client debug output.
    def __init__(self, hostport, timeout=60, authentication=None, tickets=None, debug=False):
        self.hostport = hostport
        self.timeout = timeout

        if debug:
            cctools_debug_config('chirp_python_client')
            cctools_debug_flags_set('chirp')


        if tickets and (authentication is None):
            authentication = ['ticket']

        self.__set_tickets(tickets)

        if authentication is None:
            auth_register_all()
        else:
            for auth in authentication:
                auth_register_byname(auth)

        self.identity = self.whoami()

        if self.identity == '':
            raise AuthenticationFailure(authentication)

    def __exit__(self, exception_type, exception_value, traceback):
        chirp_reli_disconnect(self.hostport)

    def __del__(self):
        chirp_reli_disconnect(self.hostport)

    def __stoptime(self, absolute_stop_time=None, timeout=None):
        if timeout is None:
            timeout = self.timeout

        if absolute_stop_time is None:
            absolute_stop_time = time.time() + timeout

        return absolute_stop_time

    def __set_tickets(self, tickets):
        tickets_str = None
        if tickets is None:
            try:
                tickets_str = os.environ['CHIRP_CLIENT_TICKETS']
            except KeyError:
                tickets_str = None
        else:
            tickets_str = ','.join(tickets)

        if tickets_str is not None:
            auth_ticket_load(tickets_str)


    ##
    # Returns a string with identity of the client according to the server.
    #
    # @param self                Reference to the current task object.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def whoami(self, absolute_stop_time=None, timeout=None):
        return chirp_wrap_whoami(self.hostport, self.__stoptime(absolute_stop_time, timeout))


    ##
    # Returns a string with the ACL of the given directory.
    # Throws an IOError on error (no such directory).
    #
    # @param self                Reference to the current task object.
    # @param path                Target directory.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def listacl(self, path='/', absolute_stop_time=None, timeout=None):
        acls = chirp_wrap_listacl(self.hostport, path, self.__stoptime(absolute_stop_time, timeout))

        if acls is None:
            raise IOError(path)

        return acls.split('\n')

    ##
    # Returns a string with the ACL of the given directory.
    # Throws a GeneralError on error.
    #
    # @param self                Reference to the current task object.
    # @param path                Target directory.
    # @param subject             Target subject.
    # @param rights              Permissions to be granted.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def setacl(self, path, subject, rights, absolute_stop_time=None, timeout=None):
        result = chirp_reli_setacl(self.hostport, path, subject, rights, self.__stoptime(absolute_stop_time, timeout))

        if result < 0:
            raise GeneralFailure('setacl', result, [path, subject, rights])

        return result

    ##
    # Set the ACL for the given directory to be only for the rights to the calling user.
    # Throws a GeneralError on error.
    #
    # @param self                Reference to the current task object.
    # @param path                Target directory.
    # @param rights              Permissions to be granted.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def resetacl(self, path, rights, absolute_stop_time=None, timeout=None):
        result = chirp_wrap_resetacl(self.hostport, path, rights, self.__stoptime(absolute_stop_time, timeout))

        if result < 0:
            raise GeneralFailure('resetacl', result, [path, rights])

        return result

    ##
    # Returns a list with the names of the files in the path.
    # Throws an IOError on error (no such directory).
    #
    # @param self                Reference to the current task object.
    # @param path                Target file/directory.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def ls(self, path, absolute_stop_time=None, timeout=None):
        dr = chirp_reli_opendir(self.hostport, path, self.__stoptime(absolute_stop_time, timeout))
        files = []

        if dir is None:
            raise IOError(path)

        while True:
            d = chirp_reli_readdir(dr)
            if d is None: break
            files.append(Stat(d.name, d.info))

        return files


    ##
    # Returns a chirp.Stat object with information on path.
    # Throws an IOError on error (e.g., no such path or insufficient permissions).
    #
    # @param self                Reference to the current task object.
    # @param path                Target file/directory.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def stat(self, path, absolute_stop_time=None, timeout=None):
        info = chirp_wrap_stat(self.hostport, path, self.__stoptime(absolute_stop_time, timeout))

        if info is None:
            raise IOError(path)

        return Stat(path, info)

    ##
    # Changes permissions on path.
    # Throws a GeneralFailure on error (e.g., no such path or insufficient permissions).
    #
    # @param self                Reference to the current task object.
    # @param path                Target file/directory.
    # @param mode                Desired permissions (e.g., 0755)
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def chmod(self, path, mode, absolute_stop_time=None, timeout=None):
        result = chirp_reli_chmod(self.hostport, path, mode, self.__stoptime(absolute_stop_time, timeout))

        if result < 0:
            raise GeneralFailure('chmod', result, [path, mode])

        return result

    ##
    # Copies local file/directory source to the chirp server as file/directory destination.
    # If destination is not given, source name is used.
    # Raises chirp.TransferFailure on error.
    #
    # @param self                Reference to the current task object.
    # @param source              A local file or directory.
    # @param destination         File or directory name to use in the server (defaults to source).
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def put(self, source, destination=None, absolute_stop_time=None, timeout=None):
        if destination is None:
            destination = source
        result = chirp_recursive_put(self.hostport,
                                     source, destination,
                                     self.__stoptime(absolute_stop_time, timeout))
        if result > -1:
            return result

        raise TransferFailure('put', result, source, destination)


    ##
    # Copies server file/directory source to the local file/directory destination.
    # If destination is not given, source name is used.
    # Raises chirp.TransferFailure on error.
    #
    # @param self                Reference to the current task object.
    # @param source              A server file or directory.
    # @param destination         File or directory name to be used locally (defaults to source).
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def get(self, source, destination=None, absolute_stop_time=None, timeout=None):
        if destination is None:
            destination = source
        result = chirp_recursive_get(self.hostport,
                                     source, destination,
                                     self.__stoptime(absolute_stop_time, timeout))

        if result > -1:
            return result

        raise TransferFailure('get', result, source, destination)

    ##
    # Removes the given file or directory from the server.
    # Raises OSError on error.
    #
    # @param self                Reference to the current task object.
    # @param path                Target file/directory.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def rm(self, path, absolute_stop_time=None, timeout=None):

        status = chirp_reli_rmall(self.hostport, path, self.__stoptime(absolute_stop_time, timeout))

        if status < 0:
            raise OSError

    ##
    # Recursively create the directories in path.
    # Raises OSError on error.
    #
    # @param self                Reference to the current task object.
    # @param path                Target file/directory.
    # @param mode                Unix permissions for the created directory.
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def mkdir(self, path, mode=493, absolute_stop_time=None, timeout=None):
        result = chirp_reli_mkdir_recursive(self.hostport, path, mode, self.__stoptime(absolute_stop_time, timeout))

        if result < 0:
            raise OSError

        return result


    ##
    # Computes the checksum of path.
    # Raises IOError on error.
    #
    # @param self                Reference to the current task object.
    # @param path                Target file.
    # @param algorithm           One of 'md5' or 'sha1' (default).
    # @param absolute_stop_time  If given, maximum number of seconds since
    #                            epoch to wait for a server response.
    #                            (Overrides any timeout.)
    # @param timeout             If given, maximum number of seconds to
    #                            wait for a server response.
    def hash(self, path, algorithm='sha1', absolute_stop_time=None, timeout=None):
        hash_hex = chirp_wrap_hash(self.hostport, path, algorithm, self.__stoptime(absolute_stop_time, timeout))

        if hash_hex is None:
            raise IOError

        return hash_hex

    ##
    # Creates a chirp job. See http://ccl.cse.nd.edu/software/manuals/chirp.html for details.
    #
    # @param job_description A dictionary with a job chirp description.
    #
    # @code
    #    job_description = {
    #        'executable': "/bin/tar",
    #        'arguments':  [ 'tar', '-cf', 'archive.tar', 'a', 'b' ],
    #        'files':      { 'task_path': 'a',
    #                        'serv_path': '/users/magrat/a.txt'
    #                        'type':      'INPUT' },
    #                      { 'task_path': 'b',
    #                        'serv_path': '/users/magrat/b.txt'
    #                        'type':      'INPUT' },
    #                      { 'task_path': 'archive.tar',
    #                        'serv_path': '/users/magrat/archive.tar'
    #                        'type':      'OUTPUT' }
    #    }
    #    job_id = client.job_create(job_description);
    # @endcode
    def job_create(self, job_description):
        job_json = json.dumps(job_description)
        job_id = chirp_wrap_job_create(self.hostport, job_json, self.__stoptime())

        if job_id < 0:
            raise ChirpJobError('create', job_id, job_json)

        return job_id


    ##
    # Kills the jobs identified with the different job ids.
    #
    # @param job_ids Job ids of the chirp jobs to be killed.
    #
    def job_kill(self, *job_ids):
        ids_str = json.dumps(job_ids)
        result = chirp_wrap_job_kill(self.hostport, ids_str, self.__stoptime())

        if result < 0:
            raise ChirpJobError('kill', result, ids_str)

        return result



    ##
    # Commits (starts running) the jobs identified with the different job ids.
    #
    # @param job_ids Job ids of the chirp jobs to be committed.
    #
    def job_commit(self, *job_ids):
        ids_str = json.dumps(job_ids)
        result = chirp_wrap_job_commit(self.hostport, ids_str, self.__stoptime())

        if result < 0:
            raise ChirpJobError('commit', result, ids_str)

        return result

    ##
    # Reaps the jobs identified with the different job ids.
    #
    # @param job_ids Job ids of the chirp jobs to be reaped.
    #
    def job_reap(self, *job_ids):
        ids_str = json.dumps(job_ids)
        result = chirp_wrap_job_reap(self.hostport, ids_str, self.__stoptime())

        if result < 0:
            raise ChirpJobError('reap', result, ids_str)

        return result

    ##
    # Obtains the current status for each job id. The value returned is a
    # list which contains a dictionary reference per job id.
    #
    # @param job_ids Job ids of the chirp jobs to be reaped.
    #
    def job_status(self, *job_ids):
        ids_str = json.dumps(job_ids)
        status = chirp_wrap_job_status(self.hostport, ids_str, self.__stoptime())

        if status is None:
            raise ChirpJobError('status', None, ids_str)

        return json.loads(status)

    ##
    # Waits waiting_time seconds for the job_id to terminate. Return value is
    # the same as job_status. If the call timesout, an empty string is
    # returned. If job_id is missing, `<job_wait>` waits for any of the user's job.
    #
    # @param waiting_time maximum number of seconds to wait for a job to finish.
    # @param job_id id of the job to wait.
    def job_wait(self, waiting_time, job_id=0):
        status = chirp_wrap_job_wait(self.hostport, job_id, waiting_time, self.__stoptime())

        if status is None:
            raise ChirpJobError('status', None, job_id)

        return json.loads(status)


##
# Python Stat object
#
# This class is used to record stat information for files/directories of a chirp server.
class Stat(object):
    def __init__(self, path, cstat):
        self._path = path
        self._info = cstat

    ##
    # Target path.
    #
    # @code
    # >>> print(s.path)
    # @endcode
    @property
    def path(self):
        return self._path

    ##
    # ID of device containing file.
    #
    # @code
    # >>> print(s.device)
    # @endcode
    @property
    def device(self):
        return self._info.cst_dev

    ##
    # inode number
    #
    # @code
    # >>> print(s.inode)
    # @endcode
    @property
    def inode(self):
        return self._info.cst_ino

    ##
    # file mode permissions
    #
    # @code
    # >>> print(s.mode)
    # @endcode
    @property
    def mode(self):
        return self._info.cst_mode

    ##
    # number of hard links
    #
    # @code
    # >>> print(s.nlink)
    # @endcode
    @property
    def nlink(self):
        return self._info.cst_nlink

    ##
    # user ID of owner
    #
    # @code
    # >>> print(s.uid)
    # @endcode
    @property
    def uid(self):
        return self._info.cst_uid

    ##
    # group ID of owner
    #
    # @code
    # >>> print(s.gid)
    # @endcode
    @property
    def gid(self):
        return self._info.cst_gid

    ##
    # device ID if special file
    #
    # @code
    # >>> print(s.rdev)
    # @endcode
    @property
    def rdev(self):
        return self._info.cst_rdev

    ##
    # total size, in bytes
    #
    # @code
    # >>> print(s.size)
    # @endcode
    @property
    def size(self):
        return self._info.cst_size

    ##
    # block size for file system I/O
    #
    # @code
    # >>> print(s.block_size)
    # @endcode
    @property
    def block_size(self):
        return self._info.cst_blksize

    ##
    # number of 512B blocks allocated
    #
    # @code
    # >>> print(s.blocks)
    # @endcode
    @property
    def blocks(self):
        return self._info.cst_blocks

    ##
    # number of seconds since epoch since last access
    #
    # @code
    # >>> print(s.atime)
    # @endcode
    @property
    def atime(self):
        return self._info.cst_atime

    ##
    # number of seconds since epoch since last modification
    #
    # @code
    # >>> print(s.mtime)
    # @endcode
    @property
    def mtime(self):
        return self._info.cst_mtime

    ##
    # number of seconds since epoch since last status change
    #
    # @code
    # >>> print(s.ctime)
    # @endcode
    @property
    def ctime(self):
        return self._info.cst_ctime

    def __repr__(self):
        return "%s uid:%d gid:%d size:%d" % (self.path, self.uid, self.gid, self.size)

class AuthenticationFailure(Exception):
    pass

class GeneralFailure(Exception):
    def __init__(self, action, status, value):
        message = "Error with %s(%s) %s" % (action, status, value)
        super(GeneralFailure, self).__init__(message)

        self.action = action
        self.status = status
        self.value = value

class TransferFailure(Exception):
    def __init__(self, action, status, source, dest):
        message = "Error with %s(%s) %s %s" % (action, status, source, dest)
        super(TransferFailure, self).__init__(message)

        self.action = action
        self.status = status
        self.source = source
        self.dest = dest

class ChirpJobError(Exception):
    def __init__(self, action, status, value):
        message = "Error with %s(%s) %s" % (action, status, value)
        super(ChirpJobError, self).__init__(message)

        self.action = action
        self.status = status
        self.value = value

# @endcode
