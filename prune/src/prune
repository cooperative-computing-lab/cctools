#!/usr/bin/env python2.6

# Copyright (c) 2010- The University of Notre Dame.
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

import os, sys, traceback, os.path
import time, threading

import readline

from work_queue import *
import prunelib
prunedb = prunelib.getdb()


HOME = os.path.expanduser("~")
CWD = os.getcwd()

terminate = False
block = False
hadoop_data = False

config_file = CWD+'/.prune.conf'
if os.path.isfile(config_file):
	with open(config_file) as f:
		for line in f.readlines():
			(meta_type,value) = line[:-1].split('\t')
			if meta_type=='sandbox':
				sandbox_prefix = value
			elif meta_type=='database':
				db_pathname = value
			elif meta_type=='data_folder':
				data_folder = value
else:
	data_folder = '/tmp/prune/data/'
	db_pathname = '/tmp/prune/___prune.db'
	sandbox_prefix = '/tmp/prune/sandbox/'

	line = raw_input('Enter location for data files: [%s]'%data_folder)
	if len(line)>0:
		data_folder = line
	line = raw_input('Enter filepath for the database: [%s]'%db_pathname)
	if len(line)>0:
		db_pathname = line
	line = raw_input('Enter location for execution sandboxes: [%s]'%sandbox_prefix)
	if len(line)>0:
		sandbox_prefix = line


def prompt():
	return 'PRUNE$ '


def user_interface():
	global block, terminate
	backs = '\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b'
	spaces = '                                        '
	while not terminate:
		try:
			line = raw_input(prompt())
			block = True
			process_line(line)
			block = False
			sys.stdout.write(backs+spaces+backs)
			sys.stdout.flush()
		except KeyboardInterrupt:
			print 'PRUNE exiting.'
			return
		except Exception:
			print traceback.format_exc()


wait_start = None
def process_line(line):
	global block, wait_start, hadoop_data
	try:
		
		if len(line)==0 or line[0]=='#':
			return True
		elif line.startswith('PUT'):
			wait = True
			filename = pname = None
			ar = line.split(' ')
			i = 1
			while i < len(ar):
				item = ar[i]
				if not filename:
					filename = item
				elif item == 'AS':
					pname = ar[i+1]
					i += 1
				elif item == 'LAZY':
					wait = False
				i += 1
			prunelib.putFile(line,filename,wait,pname)
			return True

		elif line.startswith('USE'):
			ar = line.split(' ')
			resource_type = ar[1]
			if resource_type=='local':
				concurrency = int(ar[2])
				prunelib.useLocal(concurrency)
			elif resource_type=='wq':
				if len(ar)<=2:
					prunelib.wq_check()
				else:
					master_name = ar[2]
					prunelib.useWQ(master_name)
			return True

		elif line.startswith('ENV'):
			ar = line.split(' ')
			name = ar[1]
			prunelib.env_name(name)
			return True


		elif line.startswith('GET'):
			prunelib.wq_check()
			wait = True
			filename = expr = None
			ar = line.split(' ')
			i = 1
			while i < len(ar):
				item = ar[i]
				if not expr:
					expr = item
				elif item == 'AS':
					filename = ar[i+1]
					i += 1
				elif item == 'LAZY':
					wait = False
				i += 1
			if prunelib.getFile(line,expr,filename,wait)!=0:
				return False
				#print 'There was an error transferring the file.'
			return True
			

		elif line.startswith('WORK'):
			if not wait_start:
				wait_start = time.time()

			if not prunelib.wq_check():
				print 'No work to assign to compute resources.'
				return True

			print 'work'
			ar = line.split(' ')
			name = None
			if len(ar)>2:
				if ar[2]=='FOR':
					timeout = float(ar[3])
					name = ar[1]
				else:
					timeout = float(ar[2])
			else:
				if len(ar)>1:
					name = ar[1]
				timeout = 9999999999.0
				print timeout
			
			done = False
			if name:
				res = prunelib.locate(name)
				if res:
					print name,'IS_AT',res
					return True
			if ( (time.time()-wait_start) > timeout ):
				wait_start = None
				return True
			else:
				return False
			



		elif line.startswith('LOCATE'):
			prunelib.wq_check()

			ar = line.split(' ')
			name = ar[1]
			now = True if len(ar)>2 and ar[2]=='NOW' else False
			res = prunelib.locate(name)
			if res:
				if now:
					peek(forever_back)
				print name,'IS_AT',res
				return True
			elif now:
				return False
			else:
				print 'That data does not exist yet. You could try WAITing for it, or try again later.'
				return True

		elif line.startswith('RUN'):
			ar = line.split(' ')
			name = ar[1]
			res = prunelib.locate(name)
			with open(res) as f:
				for line in f.read().splitlines():
					if len(line)>1 and line[0]!='#':
						history.append( line )
						if isBlockingLine(line):
							block += 1
						if block == 0:
							buffered_line += 1

				# Not sure if this is needed: if block == 0:
				# Not sure if this is needed: 	special_print( prompt() )
			return True

		elif line.startswith('STATUS'):
			if not wait_start:
				wait_start = time.time()

			prunelib.wq_check()

			ar = line.split(' ')
			if len(ar)>1:
				timeout = float(ar[2])
			else:
				timeout = 0.0

			res = prunelib.getQueueCounts()
			output = ''
			for r in res:
				output += '%s queue size: %i   '%( r['queue'], r['cnt'] )
			print forever_back+output

			if len(res)==1 and res[0]['queue']=='Complete':
				wait_start = None
				return True
			elif ( (time.time()-wait_start) > timeout ):
				wait_start = None
				return True
			else:
				time.sleep(10)
				return False


		elif line.startswith('ORIGIN'):
			return True
		elif line.startswith('FLOW'):
			return True
		elif line.startswith('RESET'):
			prunelib.truncate()
			prunedb.truncate()
			return True
		else:
			res = prunelib.eval(line)
			return True

	except Exception, e:
		print traceback.format_exc()
		return True



class WaitSpinner(threading.Thread):   
	def run(self):
		global terminate, block
		spin_i = 0
		spin_array = ['\\','|','/','-']
		try:
			while not terminate:
				if block > 0:
					sys.stdout.write( '\b\b'+spin_array[spin_i] )
					sys.stdout.flush()
					spin_i += 1
					if spin_i==len(spin_array):
						spin_i = 0
				time.sleep(0.05)

		except Exception,e:
			print traceback.format_exc()
spinner = WaitSpinner()
spinner.start()



try:

	prunedb.initialize(db_pathname)
	#Be sure to initialize the database first!
	prunelib.initialize(data_folder, sandbox_prefix, hadoop_data)
	with open(config_file,'w') as f:
		f.write('data_folder\t%s\n'%data_folder)
		f.write('database\t%s\n'%db_pathname)
		f.write('sandbox\t%s\n'%sandbox_prefix)


except Exception as e:
	print traceback.format_exc()

user_interface()
terminate = True
prunelib.terminate_now()
print 'PRUNE terminated'



