#!/usr/bin/env python2.6

# Copyright (c) 2010- The University of Notre Dame.
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

import os, sys, traceback, os.path
import time, threading
import tty, termios, select


from work_queue import *
import prunelib
prunedb = prunelib.getdb()


home = os.path.expanduser("~")

def peek(*arguments):
	line = ''
	for arg in arguments:
		line += ' '+str(arg)
	sys.stdout.write(line[1:])
	sys.stdout.flush()


forever_back = '\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b'
history = []
block = 0
current_line = ''
terminate = False
buffered_line = 0


def prompt():
	return 'PRUNE$ '



def isBlockingLine(line):
	return True
	# Use the following if you want to make some of the lines unblocking
	ar = line.split(' ')
	first = ar[0]
	last = ar[-1]
	if first in ['WAIT','LOCATE','USE','PUT','RUN','STATUS'] or last == 'NOW':
		return True
	return False


	
resetAll = False
for arg in sys.argv:
	if arg=='--reset':
		resetAll = True


class Console():
	def __enter__(self):
		self.old_settings = termios.tcgetattr(sys.stdin)
		tty.setcbreak(sys.stdin.fileno())
		return self
	def __exit__(self, type, value, traceback):
		termios.tcsetattr(sys.stdin, termios.TCSADRAIN, self.old_settings)
	def get_data(self,blocking=True):
		if blocking:
			return sys.stdin.read(1)
		else:
			if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
				return sys.stdin.read(1)
			return False
def getch():
	with Console() as c:
		ch = c.get_data()
		return ch


# This function only prints when the system is not blocking
def special_print(string):
	global block
	if block==0:
		sys.stdout.write(string)
		sys.stdout.flush()

def user_interface_new():
	global block, terminate
	try:
		prunelib.initialize(resetAll)
	except Exception as e:
		print e

	while not terminate:
		try:
			sys.stdout.write(prompt())
			sys.stdout.flush()

			line = sys.stdin.readline()[:-1]
			while not process_line(line):
				block = 1
			block = 0

		except KeyboardInterrupt:
			terminate = True
			print 'Exiting'
		except Exception:
			print traceback.format_exc()

def user_interface():
	global history, current_line, block, buffered_line, processed_cnt
	try:
		ch = getch()
		key = ord(ch)
		lines_back = 0
		chars_back = 0
		while key!=3:
			if key==10: #Enter
				special_print('\n')
				chars_back = 0
				lines_back = 0

				if len(current_line)>0 and current_line[0]!='#':
					history.append(current_line)
					if isBlockingLine(current_line):
						block += 1
					if block == 0:
						buffered_line += 1

				if block == 0:
					special_print( prompt() )

				current_line = ''
			elif key==27:
				ch = getch()
				key = ord(ch)
				if key==91:
					ch = getch()
					key = ord(ch)
					if key==65: #Up arrow
						for c in current_line:
							special_print( '\b \b' )
						if lines_back<len(history):
							current_line = history[-lines_back]
							special_print( current_line )
							lines_back += 1
						else:
							current_line = ''
					elif key==66: #Down arrow
						for c in current_line:
							special_print( '\b \b' )
						if lines_back>1:
							lines_back -= 1
							current_line = history[-lines_back]
							special_print( current_line )
						else:
							current_line = ''
					elif key==68: #Left arrow
						if chars_back<len(current_line):
							special_print( '\b' )
							chars_back += 1
					elif key==67: #Right arrow
						if chars_back>0:
							special_print( current_line[len(current_line)-chars_back] )
							chars_back -= 1
			elif key==127: #Backspace
				if chars_back==0:
					if len(current_line)>0:
						current_line = current_line[:-1]
						special_print( '\b \b' )
				else:
					l = len(current_line)
					current_line = current_line[:l-chars_back-1] + current_line[l-chars_back:]
					special_print( '\b'+current_line[l-chars_back-1:]+' \b' )
					for b in range(0,chars_back):
						special_print( '\b' )
			else:
				if chars_back>0:
					current_line = current_line[0:len(current_line)-chars_back] + ch + current_line[len(current_line)-chars_back:]
					special_print( ch+current_line[len(current_line)-chars_back:] )
					for i in range(0,chars_back):
						special_print( '\b' )
				else:
					current_line += ch
					special_print( ch )

			ch = getch()
			key = ord(ch)
		special_print('\n')
	except KeyboardInterrupt:
		print ''
		if block>0:
			special_print('\n')
			chars_back = 0
			lines_back = 0
			current_line = ''
		else:
			return
	except Exception, e:
		print traceback.format_exc()



wait_start = None
def process_line(line):
	global block, done_wq_tasks, wait_start, history
	try:
		
		if len(line)==0 or line[0]=='#':
			return True
		elif line.startswith('PUT'):
			wait = True
			filename = pname = None
			ar = line.split(' ')
			i = 1
			while i < len(ar):
				item = ar[i]
				if not filename:
					filename = item
				elif item == 'AS':
					pname = ar[i+1]
					i += 1
				elif item == 'LAZY':
					wait = False
				i += 1
			prunelib.putFile(line,filename,wait,pname)
			return True

		elif line.startswith('USE'):
			ar = line.split(' ')
			resource_type = ar[1]
			if resource_type=='local':
				concurrency = int(ar[2])
				prunelib.useLocal(concurrency)
			elif resource_type=='wq':
				if len(ar)<=2:
					prunelib.wq_check()
				else:
					master_name = ar[2]
					prunelib.useWQ(master_name)
			return True

		elif line.startswith('ENV'):
			ar = line.split(' ')
			name = ar[1]
			prunelib.env_name(name)
			return True


		elif line.startswith('GET'):
			wait = True
			filename = expr = None
			ar = line.split(' ')
			i = 1
			while i < len(ar):
				item = ar[i]
				if not expr:
					expr = item
				elif item == 'AS':
					filename = ar[i+1]
					i += 1
				elif item == 'LAZY':
					wait = False
				i += 1
			if prunelib.getFile(line,expr,filename,wait)!=0:
				print 'There was an error transferring the file.'
			return True
			

		elif line.startswith('GO'):
			if not wait_start:
				wait_start = time.time()

			if not prunelib.wq_check():
				return True

			ar = line.split(' ')
			name = None
			if len(ar)>2:
				if ar[2]=='FOR':
					timeout = float(ar[3])
					name = ar[1]
				else:
					timeout = float(ar[2])
			else:
				if len(ar)>1:
					name = ar[1]
				timeout = 9999999999.0
			
			done = False
			if name:
				res = prunelib.locate(name)
				if res:
					print name,'IS_AT',res
					return True
			if ( (time.time()-wait_start) > timeout ):
				wait_start = None
				return True
			else:
				return False
			



		elif line.startswith('LOCATE'):
			prunelib.wq_check()

			ar = line.split(' ')
			name = ar[1]
			now = True if len(ar)>2 and ar[2]=='NOW' else False
			res = prunelib.locate(name)
			if res:
				if now:
					peek(forever_back)
				print name,'IS_AT',res
				return True
			elif now:
				return False
			else:
				print 'That data does not exist yet. You could try WAITing for it, or try again later.'
				return True

		elif line.startswith('RUN'):
			ar = line.split(' ')
			name = ar[1]
			res = prunelib.locate(name)
			with open(res) as f:
				for line in f.read().splitlines():
					if len(line)>1 and line[0]!='#':
						history.append( line )
						if isBlockingLine(line):
							block += 1
						if block == 0:
							buffered_line += 1

				# Not sure if this is needed: if block == 0:
				# Not sure if this is needed: 	special_print( prompt() )
			return True

		elif line.startswith('STATUS'):
			if not wait_start:
				wait_start = time.time()

			prunelib.wq_check()

			ar = line.split(' ')
			if len(ar)>1:
				timeout = float(ar[2])
			else:
				timeout = 0.0

			res = prunelib.getQueueCounts()
			output = ''
			for r in res:
				output += '%s queue size: %i   '%( r['queue'], r['cnt'] )
			print forever_back+output

			if len(res)==1 and res[0]['queue']=='Complete':
				wait_start = None
				return True
			elif ( (time.time()-wait_start) > timeout ):
				wait_start = None
				return True
			else:
				time.sleep(10)
				return False


		elif line.startswith('ORIGIN'):
			return True
		elif line.startswith('FLOW'):
			return True
		else:
			res = prunelib.eval(line)
			return True

	except Exception, e:
		print traceback.format_exc()
		return True


processed_cnt = 0
class bgThread (threading.Thread):
	def __init__(self, threadID, name):
		threading.Thread.__init__(self)
		self.threadID = threadID
		self.name = name
	def run(self):
		global wq, block, buffered_line, processed_cnt, done_wq_tasks, processed_wq_tasks
		#This is where you could lock if needed: threadLock.acquire()
		simulateProcessing = False
		try:
			prunelib.initialize(resetAll)
		except Exception as e:
			print e
		peek( prompt() )
		
		next_poll = 0
		while not terminate:
			was_blocking = block
			now = time.time()
			if processed_cnt<len(history):
				line = history[processed_cnt]
				if line[0]!='#':
					blocking_line = isBlockingLine(line)
					if buffered_line<processed_cnt:
						print forever_back+prompt()+line
						buffered_line += 1
					
					if simulateProcessing:
						processed = True
					else:
						try:
							processed = process_line(line)
						except Exception, e:
							print traceback.format_exc()
							processed = True

					if processed:
						#TODO: Reconstruct the command with ids not names for the preserved command (2nd arg)
						prunelib.cmd_log(line,'')

						if isBlockingLine(line):
							if simulateProcessing:
								time.sleep(3)
							block -= 1
						processed_cnt += 1
			if was_blocking and block == 0:
				if processed_cnt==len(history):
					peek( forever_back+prompt()+current_line )
					buffered_line += 1
			
			if False and now > next_poll:
				print 'do'
				t = prunelib.wq_do()
				if t:
					done_wq_tasks.append(t)
					next_poll = now + 0.1
				else:
					next_poll = now + 30
			prunelib.check_transfers()
			time.sleep(0.001)
			prunelib.local_check()

			sys.stdout.flush()
			time.sleep(0.1)

		#This is where you could unlock if needed: threadLock.release()
#Setup a lock if needed: threadLock = threading.Lock()
bg = bgThread(1, "Background processing")
bg.start()



class WaitSpinner(threading.Thread):   
	def run(self):
		global terminate, block
		spin_i = 0
		spin_array = ['\\','|','/','-']
		try:
			while not terminate:
				if block > 0:
					sys.stdout.write( '\b\b'+spin_array[spin_i] )
					sys.stdout.flush()
					spin_i += 1
					if spin_i==len(spin_array):
						spin_i = 0
				time.sleep(0.05)

		except Exception,e:
			print traceback.format_exc()
spinner = WaitSpinner()
spinner.start()





user_interface()
terminate = True
prunelib.terminate_now()
print 'PRUNE terminated'



