<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="en">

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<link rel="stylesheet" type="text/css" href="manual.css">
<title>Prune User's Manual</title>
</head>

<body>

<div id="manual">
<h1>Prune User's Manual</h1>

<p style="text-align: right;"><b>Last edited: March 2016</b></p>

<p>Prune is Copyright (C) 2003-2004 Douglas Thain and Copyright (C) 2005- The University of Notre Dame.<br>
All rights reserved.<br>
This software is distributed under the GNU General Public License.<br>
See the file COPYING for details.</p>


<h2 id="overview">Overview<a class="sectionlink" href="#overview" title="Link to this section.">&#x21d7;</a></h2>

<p>Prune is a system for executing and precisely preserving scientific workflows.
Collaborators can verifiy research results and easily extend them
at a granularity that makes sense to users,
since the granularity was determined by a user.</p>


<h2 id="overview">API Commands<a class="sectionlink" href="#overview" title="Link to this section.">&#x21d7;</a></h2>


<p>The following client API commands are accessible in a Python script using the prune client library:</p>

<ul>
  <li>
    <p>id = file_add( &lt;filename&gt; ): Copies the content for the given filename into a persistent Prune database. The function returns a checksum for the file to be used as a reference to the data in later operations.
    <br>Ex. D1 = prune.file_add( 'nouns.txt' )</p>
  </li>
  <li>
    <p>id = envi_add( engine=&lt;type&gt;, open=&lt;start_command&gt;, close=&lt;end_command&gt;, args=[&lt;id&gt;...], params=[&lt;filename&gt;...]): Defines how to create an appropriate computational environment for commands to run as pieces of a workflow. The function returns an identifier for referring to the reproducible environment.
    <br>Ex. E1 = prune.envi_add(engine='wrapper', open='tar -zxf jellyfish.tar.gz', close='rm -rf jellyfish', args=[D0], params=['jellyfish.tar.gz'])</p>
  </li>
  <li>
    <p>[id...] = call_add( args=[&lt;id&gt;...], params=[&lt;filename&gt;...], cmd=&lt;command&gt;, env=environment_id, returns=[&lt;filename&gt;...]: Puts the arguments (args) into a sandbox, each with the appropriate parameter (params) filename inside the sandbox. Then executes the command in an instance of the specified environment. Then retrieves the resulting files (returns) created by the command. The function returns ids referring to the return files (even if they have not yet been created).
    <br>Ex. D3, = prune.task_add( args=[D1], params=['input.txt'], cmd='sort input.txt > output.txt', env=E1, returns=['output.txt'] )</p>
  </li>
  <li>
    <p>export( [&lt;id&gt;...], &lt;filename&gt;, &#123;options&#125; ): For a single id, this stores the data referred to by the id into a file in the user's current working directory. For multiple ids, this embeds the calls needed to create these files into a single file. A lineage option specifies how many elements down the dependency chain should be included in the file. These files can then be used as input for the import command (see next).
    <br>Ex. prune.export( D5, 'merged_words.txt' )
    <br>Ex. prune.export( D5, 'merge_sort.prune', lineage=2 )
    </p>
  </li>
  <li>
    <p>import( &lt;filename&gt; ): Imports the embedded objects from the file into the local graph of Prune objects. Any Prune calls may need to be executed before retrieving result files.
    <br>Ex. prune.import( 'merge_sort.prune' )
    </p>
  </li>

</ul>


<h2 id="overview">Workflow execution<a class="sectionlink" href="#overview" title="Link to this section.">&#x21d7;</a></h2>


<p>Calls added into Prune are not executed until workers are provided. The 'prune_worker' command will spawn local (by default) background processes to execute any calls that haven't been executed already. The number of concurrent background processes is configureable and the worker can also be configured to use Work Queue to remotely execute calls. Run 'prune_worker -h' to see the options. </p>

<p>If a worker is killed, the state is maintained in a database and the worker can be restarted to resume where it left off. If a call fails to produce the expected files, the sandbox the call was run in (for local workers) is preserved so that the user can observe the failure manually and directly.</p>


<h2 id="overview">Example: Merge Sort<a class="sectionlink" href="#overview" title="Link to this section.">&#x21d7;</a></h2>


  <p>Here is a full example of a merge sort specification using Prune:</p>

  <code style="margin-right: auto;">
#!/usr/bin/env cctools_python
# CCTOOLS_PYTHON_VERSION 2.7 2.6

# Copyright (c) 2010- The University of Notre Dame.
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

from prune import client
prune = client.Connect() #Connect to SQLite3

###### Import sources stage ###### 
E1 = prune.nil
D1 = prune.file_add( 'nouns.txt' )
D2 = prune.file_add( 'verbs.txt' )

###### Sort stage ###### 
D3, = prune.task_add( returns=['output.txt'],
  env=E1, cmd='sort input.txt > output.txt',
  args=[D1], params=['input.txt'] ) 
D4, = prune.task_add( returns=['output.txt'],
  env=E1, cmd='sort input.txt > output.txt',
  args=[D2], params=['input.txt'] )

###### Merge stage ###### 
D5, = prune.task_add(
  returns=['merged_output.txt'], env=E1,
  cmd='sort -m input*.txt > merged_output.txt',
  args=[D3,D4], params=['input1.txt','input2.txt'] )

###### Export final data ######
# First run the 'prune_worker' command to execute the workflow,
# then uncomment the following line and run this script again.
#prune.export( D5, 'merged_words.txt' )


###### Export publishable workflow ###### 
prune.export( D5, 'merge_sort.prune', lineage=2 )

  </code>

In order to export the final merged words file, workers need to be initiated to execute the calls. The following command will use local processes to execute the calls and generate the results.

  <code style="margin-right: auto;">
    <span class="prompt">$ </span> prune_worker
  </code>

Once prune_worker exits, the commented out export command in the example above can be uncommented and the whole script can be run again to put the final results into the current working directory with the merged_words.txt filename.


