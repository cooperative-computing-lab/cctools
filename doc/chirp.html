<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>

<head>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8">
<title>Chirp User's Manual</title>
<style type="text/css">
  body {
    background: gray;
  }
  #manual {
    background: white;
    border: 2px solid #000000;
    padding: 20px;
    max-width: 1000px;
    margin: 20px auto 20px auto;
  }
  h1 {
    border-top: 3px solid #000000;
    border-bottom: 3px solid #000000;
    font-weight: bold;
    text-align: center;
  }
  h2 {
    border-bottom: 2px solid #000000;
    border-left: 5px solid #000000;
    font-weight: bold;
    padding-left: 10px;
  }
  h3 {
    border-bottom: 2px solid #000000;
    border-left: 5px double #000000;
    font-weight: bold;
    padding-left: 10px;
    margin-left: 20px;
  }
  h4 {
    border-bottom: 1px solid #000000;
    border-left: 5px inset #000000;
    font-weight: bold;
    padding-left: 10px;
    margin-left: 30px;
  }
  hr {
    border: 0;
    width: 80%;
    height: 5px;
    color: black;
  }
  p {
    font: normal normal normal 18px Times, serif;
  }
  ul, ol {
    font: normal normal normal 20px Times, serif;
  }
  table {
    background: #dddddd;
    border-collapse: collapse;
    margin: 10px auto 10px auto;
  }
  tr {
    border-spacing: 0;
    margin: none;
    padding: 5px;
  }
  td {
    border: 2px solid black;
    margin: none;
    padding: 10px;
  }
  tt {
    font: normal normal normal 16px "Courier New", Courier, monospace;
  }
  code {
    background: #ffffcc;
    border: 1px dashed #000000;
    color: #000000;
    display: block;
    /*font: normal normal normal .75em/100% "Courier New", Courier, monospace;*/
    font: normal normal normal 18px "Courier New", Courier, monospace;
    margin: 10px 0 10px 20px;
    max-width: 65em; /* a little more than .75*80 */
    /* FIXME always takes up max WIDTH!!! :( */
    overflow-x: auto; /* CSS 3 */
    padding: 10px 10px 10px 10px;
    text-align: left;
    text-decoration: none;
    white-space: pre;
  }
  .sectionlink {
    color: blue;
    border: none;
    display: none;
    float: right;
    font-weight: normal;
    text-decoration: none;
  }
  code .prompt {
    color: #cc0000;
    font-weight: bold;
  }
  h1:hover .sectionlink, h2:hover .sectionlink, h3:hover .sectionlink, h4:hover .sectionlink, h5:hover .sectionlink, h6:hover .sectionlink {
    display: block;
  }
  :target {
    background-color: #ededed;
    border: dashed black 2px;
    border-radius: 8px;
    font-weight: bold;
    padding: 10px;
  }
</style>
</head>

<body>

<div id="manual">
<h1>Chirp User's Manual</h1>

<p style="text-align: right;"><b>Last edited: January 2014</b></p>

<p>Chirp is Copyright (C) 2003-2004 Douglas Thain and Copyright (C) 2005- The
University of Notre Dame.  All rights reserved.  This software is distributed
under the GNU General Public License.  See the file COPYING for details.</p>

<p><b>Please use the following citation for Chirp in a scientific publication:</b></p>

<ul>
    <li>Douglas Thain, Christopher Moretti, and Jeffrey Hemmes, <a href="http://www.cse.nd.edu/~dthain/papers/chirp-jgc.pdf">Chirp: A Practical Global Filesystem for Cluster and Grid Computing</a>, <i>Journal of Grid Computing</i>, Springer, 2008. DOI: 10.1007/s10723-008-9100-5.  (The original is available on <a href="http://www.springerlink.com">http://www.springerlink.com</a>.)</li>
</ul>

<h2 id="overview">Overview<a class="sectionlink" href="#overview" title="Link to this section.">&#x21d7;</a></h2>

<p>Chirp is a system for performing input and output across the Internet.
Using Chirp, an ordinary user can share storage space and data with friends and
colleagues without requiring any sort of administrator privileges anywhere.</p>

<p>Chirp is like a distributed filesystem (such as NFS) except that it can be
run over wide area networks and requires no special privileges on either the
client or the server end.  Chirp allows the end user to set up fine-grained
access control so that data can be shared (or not shared) with the right
people.</p>

<p>Chirp is also like a file transfer system (such as FTP) that provides
streaming point-to-point data transfer over the Internet.  However, Chirp also
provides fine-grained Unix-like data access suitable for direct access by
ordinary programs.</p>

<p>Chirp also includes several advanced features for authentication tickets,
space allocation, and more.  However, each of these features must be explicitly
enabled, so you don't have to worry about them if all you want is simple
storage access.  Read on below for more details.</p>

<p> Begin by <a
href="http://www.cse.nd.edu/~ccl/software/manuals/install.html">installing the
cctools</a> on your system.  When you are ready, proceed below.</p>

<h2 id="running">Running a Chirp Server<a class="sectionlink" href="#running" title="Link to this section.">&#x21d7;</a></h2>

<p>Running a Chirp server is easy.  You may run a Chirp server as any ordinary
user, and you do <b>not</b> need to install the software or even run the
programs as root.  To run a Chirp server, you must do three things: pick a
storage directory, run the server, and then adjust the access control.</p>

<ol>
  <li>
    <b>Pick a storage directory.</b>  The Chirp server will only allow access
    to the directory that you choose.  It could be a scratch directory, your
    home directory, or even your filesystem root.   For now, let's store
    everything in a temporary directory:

    <code>/tmp/mydata</code>
  </li>
  <li>
    <b>Run the server.</b>  Simply run <tt>chirp_server</tt> and direct it to
    your storage directory:

    <code><span class="prompt">$ </span>chirp_server -r /tmp/mydata &amp;</code>
  <li>
    <b>Adjust the access control.</b>  When first started, the Chirp server
    will allow access only to YOU from the same host.  You will probably want
    to change this to allow access to other people and hosts.  To adjust the
    access control, use the <tt>chirp</tt> tool and the <tt>setacl</tt> command
    to set the access control list.  For example, to also allow other hosts in
    your domain to read and write the server:

    <code><span class="prompt">$ </span>chirp localhost
 chirp:localhost:/&gt; setacl . hostname:*.mydomain.edu write</code>
  </li>
</ol>

<p>Now that you have a server running on one machine, let's use some tools to
move data to and from your server.</p>

<h2 id="access">Accessing Chirp Servers<a class="sectionlink" href="#access" title="Link to this section.">&#x21d7;</a></h2>

<p>The easiest way to access Chirp servers is by using a tool called <b><a
href="http://www.cse.nd.edu/~ccl/software/parrot">Parrot</a></b>.  Parrot is a
personal virtual filesystem: it "speaks" remote I/O operations on behalf of
ordinary programs.  For example, you can use Parrot with your regular shell to
list and access Chirp servers like so:</p>

<code style="margin-right: auto;"><span class="prompt">$ </span>parrot_run tcsh
<span class="prompt">$ </span>cd /chirp
<span class="prompt">$ </span>ls
angband.somewhere.edu:9094
dustpuppy.somewhere.edu:9094
peanuts.somewhere.edu:9094
...
<span class="prompt">$ </span>cd /chirp/peanuts.somewhere.edu
<span class="prompt">$ </span>cp /tmp/bigfile .
<span class="prompt">$ </span>ls -la
total 804
drwx------    2 fred   users          4096 Sep 10 12:40 .
drwx------    2 fred   users          4096 Sep 10 12:40 ..
-rw-r--r--    1 fred   users     104857600 Sep 10 12:57 bigfile
-rw-r--r--    1 fred   users           147 Sep 10 12:39 hosts
<span class="prompt">$ </span>parrot_getacl
unix:fred rwlda
hostname:hedwig rl
...
</code>

<p>(If you are having difficulting accessing your server, have a look at
"debugging hints" below.)</p>

<p>Parrot is certainly the most convenient way to access storage, but it has
some limitations: it only works on Linux, and it imposes some performance
penalty.</p>

<p>You can also attach to Chirp filesystems by using the FUSE package to attach
Chirp as a kernel filesystem module.  Unlike Parrot, this requires superuser
privileges to install the FUSE package, but will likely work more reliably on a
larger number of programs.  You can do this with either <a
href="http://fuse.sourceforge.net">Linux FUSE</a> or <a
href="http://code.google.com/p/macfuse">MacFuse</a>.  Once you have downloaded
and installed FUSE, simply run <tt>chirp_fuse</tt> with the name of a directory
on which the filesystem should be mounted.  For example:</p>

<code style="margin-right: auto;"><span class="prompt">$ </span>mkdir /tmp/chirp
<span class="prompt">$ </span>chirp_fuse /tmp/chirp
<span class="prompt">$ </span>cd /tmp/chirp
<span class="prompt">$ </span>ls -la
total 9742
dr-xr-xr-x   0 fred users    6697 Feb 22 13:54 albus.cse.nd.edu:9094
dr-xr-xr-x   0 fred users    6780 Feb 22 13:54 aluminum.helios.nd.edu:9094
dr-xr-xr-x   0 fred users   27956 Feb 22 13:54 angband.cse.nd.edu:9094
dr-xr-xr-x   0 fred users    6466 Feb 22 13:54 angelico.helios.nd.edu:9094
...
</code>

<p>For more portable, explicit control of a Chirp server, use the Chirp command
line tool.  This allows you to connect to a server, copy files, and manage
directories, much like an FTP client:</p>

<code style="margin-right: auto;"><span class="prompt">$ </span>chirp
 ...
 chirp::&gt; open myhost.somewhere.edu
 chirp:myhost.somewhere.edu:/&gt; put /tmp/bigfile
file /tmp/bigfile -&gt; /bigfile (11.01 MB/s)
 chirp:myhost.somewhere.edu:/&gt; ls -la
dir      4096 .                                        Fri Sep 10 12:40:27 2004
dir      4096 ..                                       Fri Sep 10 12:40:27 2004
file      147 hosts                                    Fri Sep 10 12:39:54 2004
file 104857600 bigfile                                 Fri Sep 10 12:53:21 2004
 chirp:myhost.somewhere.edu:/&gt;
</code>

<p>In scripts, you may find it easier to use the standalone commands
<tt>chirp_get</tt> and <tt>chirp_put</tt>, which move single files to and from
a Chirp server.  These commands also allow for streaming data, which can be
helpful in a shell pipeline.  Also, the -f option to both commands allows you
to follow a file, much like the Unix <tt>tail</tt> command:</p>

<code style="margin-right: auto;"><span class="prompt">$ </span>tar cvzf archive.tar.gz ~/mydata
<span class="prompt">$ </span>chirp_put archive.tar.gz myhost.somewhere.edu archive.tar.gz
<span class="prompt">$ </span>...
<span class="prompt">$ </span>chirp_get myhost.somewhere.edu archive.tar.gz - | tar xvzf
<span class="prompt">$ </span>...
<span class="prompt">$ </span>chirp_get -f myhost.somewhere.edu logfile - |&amp; less
<span class="prompt">$ </span>
</code>

<p>You can also write programs that access the Chirp C interface directly.
This interface is relatively self explanatory: programs written to use this
library may perform explicit I/O operations in a manner very similar to Unix.
For more information, see the <a
href="http://www.cse.nd.edu/~ccl/software/howto/code.shtml">HOWTO: Write Code
that Uses Chirp</a></p>

<h2 id="finding">Finding Chirp Servers<a class="sectionlink" href="#finding" title="Link to this section.">&#x21d7;</a></h2>

<p>Now that you know how to run and use Chirp servers, you will need a way to
keep track of all of the servers that are available for use.  For this purpose,
consult the Chirp <a href="http://catalog.cse.nd.edu:9097">storage catalog</a>.
This web page is a list of all known Chirp servers and their locations.  Note
that this same list appears if you use Parrot to perform an <tt>ls</tt> on
<tt>/chirp</tt></p>

<p>The storage catalog is highly dynamic.  By default, each Chirp server makes
itself known to the storage catalog every five minutes.  The catalog server
records and reports all Chirp servers that it knows about, but will discard
servers that have not reported for fifteen minutes.</p>

<p>If you <b>do not</b> want your servers to report to a catalog, then run them
with this option:</p>

<code><span class="prompt">$ </span>chirp_server -u -</code>

<p>Alternatively, you may establish your own catalog server.  This can be
useful for keeping your systems logically distinct from the main storage pool,
but can also help performance and availability if your catalog is close to your
Chirp servers.  The catalog server is installed in the same place as the Chirp
server.  Simply run it on any machine that you like and then direct your Chirp
servers to update the new catalog with the -u option.  The catalog will be
published via HTTP on port 9097 of the catalog machine.</p>

<p>For example, suppose that you wish to run a catalog server on a machine
named <tt>dopey</tt> and a Chirp server on a machine named <tt>sneezy</tt>:</p>

<code>dopey<span class="prompt">$ </span>catalog_server
...
sneezy<span class="prompt">$ </span>chirp_server -u dopey [more options]
</code>

<p>Finally, point your web browser to: <tt>http://dopey:9097</tt></p>

<p>Or, set an environment variable and use Parrot:</p>

<code><span class="prompt">$ </span>setenv CATALOG_HOST dopey
<span class="prompt">$ </span>parrot_run tcsh
<span class="prompt">$ </span>ls /chirp
</code>

<p>And you will see <a href="http://catalog.cse.nd.edu:9097">something like
this.</a> You may easily run multiple catalogs for either scalability or fault
tolerance.  Simply give each Chirp server multiple -u options to name each
running catalog.</p>

<p>(Hint: If you want to ensure that your chirp and catalog servers run
continuously and are automatically restarted after an upgrade, consider using
<a href="watchdog.html">Watchdog</a>.)</p>

<h2 id="security">Security<a class="sectionlink" href="#security" title="Link to this section.">&#x21d7;</a></h2>

<p>Now that you have an idea how Chirp can be used, let's discuss security in
more detail.  Different sites require different levels of security and
different technological methods of enforcing security.  For these reasons,
Chirp has a very flexible security system that allows for a range of tools and
policies from simple address checks to Kerberos authentiation.</p>

<p>Security really has two aspects: authentication and authorization.
Authentication deals with the question "Who are you?" Once your identity has
been established, then authorization deals with the question "What are you
allowed to do?" Let's deal with each in turn.</p>

<h3 id="security.authentication">Authentication<a class="sectionlink" href="#security.authentication" title="Link to this section.">&#x21d7;</a></h3>

<p>Chirp supports the following authentication schemes:</p>

<table>
<tr><td><b>Type</b><td><b>Summary</b><td><b>Regular User?</b><td><b>Root?</b>
<tr><td><td><td>(non-root)<td>(root)
<tr><td>kerberos   <td> Centralized private key system<td> no <td> yes (host cert)
<tr><td>globus     <td> Distributed public key system<td> yes (user cert) <td> yes (host cert)
<tr><td>unix       <td> Authenticate with local unix user ids. <td> yes <td> yes
<tr><td>hostname   <td> Reverse DNS lookup <td> yes <td> yes
<tr><td>address    <td> Identify by IP address <td> yes <td> yes
</table>

<p>The Chirp tools will attempt all of the authentication types that are known
and available in the order above until one works.  For example, if you have
Kerberos installed in your system, Chirp will try that first.  If not, Chirp
attempts the others.</p>

<p>Once an authentication scheme has succeeded, Chirp assigns the incoming user
a <b>subject</b> that describes both the authentication method and the user
name within that method.  For example, a user that authenticates via Kerberos
might have the subject:</p>

<code>kerberos:dthain@nd.edu</code>

<p>A user authenticating with Globus credentials might be:<br> (Note that
Chirp substitutes underscores for spaces.)</p>

<code>globus:/O=Cooperative_Computing_Lab/CN=Douglas_L_Thain</code>

<p>While another user authenticating by local unix ids might be:</p>

<code>unix:dthain</code>

<p>While a user authenticating by simple hostnames might be:</p>

<code>hostname:pigwidgeon.cse.nd.edu</code>

<p>Take note that Chirp considers all of the subjects as different identities,
although some of them might correspond to the same person in varying
circumstances.</p>

<h3 id="security.authorization">Authorization<a class="sectionlink" href="#security.authorization" title="Link to this section.">&#x21d7;</a></h3>

<p>Once Chirp has authenticated your identity, you are logged into a server.
However, when you attempt to read or manipulate files on a server, Chirp checks
to see whether you are authorized to do so.  This is determined by <b>access
control lists</b> or <b>ACLs</b>.</p>

<p> Every directory in a Chirp server has an ACL, much like filesystems such as
as AFS or NTFS.  To see the ACL for a directory, use the Chirp tool and the
<tt>getacl</tt> command:</p>

<code> chirp:host.mydomain.edu:/&gt; getacl
unix:dthain rwlda
hostname:*.mydomain.edu rwl
</code>

<p>Or, if you are using Parrot, you can use <tt>parrot_getacl</tt> to examine
ACLs in the same way:</p>

<code><span class="prompt">$ </span>parrot_run tcsh
<span class="prompt">$ </span>cd /chirp/host.mydomain.edu
<span class="prompt">$ </span>parrot_getacl
unix:dthain rwlda
hostname:*.mydomain.edu rwl
</code>

<p>This ACL indicates that the subject <tt>unix:dthain</tt> has five access
rights, while the subject pattern <tt>hostname:*.mydomain.edu</tt> has only
three access rights. The access rights are as follows:</p>

<table>
<tr><td><b>r</b> <td> - The subject may read items in the directory.
<tr><td><b>w</b> <td> - The subject may write items in the directory.
<tr><td><b>l</b> <td> - The subject may list the directory contents.
<tr><td><b>d</b> <td> - The subject may delete items in the directory.
<tr><td><b>p</b> <td> - The subject may put new files into the directory. 
<tr><td><b>a</b> <td> - The subject may administer the directory, including changing the ACL.
<tr><td><b>x</b> <td> - The subject may execute programs in the directory.
<tr><td><b>v</b> <td> - The subject may reserve a directory.
</table>

<p>Access rights often come in combinations, so there are a few aliases for
your convenience:</p>

<table>
<tr><td><b>read</b>    <td> - alias for <b>rl</b><br>
<tr><td><b>write</b>   <td> - alias for <b>rwld</b><br>
<tr><td><b>admin</b>   <td> - alias for <b>rwlda</b><br>
<tr><td><b>none</b>    <td> - delete the entry<br>
</table>

<p>To change an access control list on a directory, use the <tt>setacl</tt>
command in the Chirp command line tool:</p>

<code> chirp:host.mydomain.edu:/&gt; setacl / kerberos:dthain@nd.edu write
 chirp:host.mydomain.edu:/&gt; getacl 
unix:dthain rwlda
hostname:*.mydomain.edu rwl
kerberos:dthain@nd.edu rwld
</code>

<p>Note that for subject names that contain spaces, you should simply
substitute underscores.  For example, if your subject name is <tt>/O=Univ of
Somewhere/CN=Fred Flint</tt>, then you might issue a <tt>setacl</tt> command
like this:</p>

<code> chirp:host.mydomain.edu:/&gt; setacl / /O=Univ_of_Somewhere/CN=Fred_Flint rwlda</code>

<p>Or, you can accomplish the same thing using <tt>parrot_setacl</tt> inside of
Parrot:</p>

<code><span class="prompt">$ </span>parrot_run tcsh
<span class="prompt">$ </span>cd /chirp/host.mydomain.edu
<span class="prompt">$ </span>parrot_setacl . /O=Univ_of_Somewhere/CN=Fred_Flint rwlda
</code>

<p>The meaning of ACLs is fairly obvious, but there are few subtleties you should know:</p>

<p><b>Rights are generally inherited.</b>  When a new directory is created, it
automatically gets the ACL of its parent.  Exception: read about the
<b>reserve</b> right below.</p>

<p><b>Rights are generally not hierarchical.</b>  In order to access a
directory, you only need the appropriate permissions on <i>that</i> directory.
For example, if you have permission to write to <tt>/data/x/y/z</tt>, you do
<b>not</b> need any other permissions on <tt>/data</tt>, <tt>/data/x</tt> and
so forth.  Of course, it may be difficult to discover a deep directory without
rights on the parents, but you can still access it.</p>

<p><b>The delete right is absolute.</b>  If you have permission to delete a
directory, then you are able to delete the <i>entire</i> subtree that it
contains, regardless of any other ACLs underneath.</p>

<p>Note that it is possible to use Chirp to export an existing directory tree
without manually populating every directory with ACLs.  Simply create an ACL in
an external file, and then use the -A option to tell the Chirp server to use
that file as the default ACL.</p>

<h3 id="security.reservation">Reservation<a class="sectionlink" href="#security.reservation" title="Link to this section.">&#x21d7;</a></h3>

<p>The <b>v - reserve</b> right is an important concept that deserves its own
discussion.</p>

<p>A shared-storage environment such as Chirp aims to allow many people to read
and write common storage space.  Of course, with many people reading and
writing, we need some mechanism to make sure that everybody does not step on
each other's toes.</p>

<p>The <b>reserve</b> right allows a user to create what is essentially a fresh
workspace for their own use.  When a user creates a new directory and has the
<b>v</b> right (but not the <b>w</b> right), Chirp will create a new directory
with a fresh ACL that gives the creating user restricted rights.</p>

<p>A good way to use the reserve right is with a wildcard at the top directory.
Here's an example.  Suppose that Fred creates a new Chirp server on the host
<tt>bigwig</tt>. Initially, no-one except Fred can access the server.  The
first time it starts, the Chirp server initializes its root directory with the
following ACL:</p>

<code>unix:fred rwla</code>

<p>Now, Fred wants other users in his organization to be able to use this
storage, but doesn't want them messing up his existing data.  So, Fred uses the
Chirp tool to give the list (<b>l</b>) and reserve (<b>v</b>) rights to anyone
calling from any machine in his organization:</p>

<code> chirp:bigwig:&gt; setacl / hostname:*.somewhere.edu lv(rwlda)
 chirp:bigwig:&gt; getacl /
unix:fred rwlda
hostname:*.somewhere.edu lv(rwlda)
</code>

<p>Now, any user calling from anywhere in <tt>somewhere.edu</tt> can access
this server.  But, all that any user can do is issue <tt>ls</tt> or
<tt>mkdir</tt> in the root directory.  For example, suppose that Betty logs
into this server from <tt>ws1.somewhere.edu</tt>.  She can not modify the root
directory, but she can create her own directory:</p>

<code> chirp:bigwig:&gt; mkdir /mydata</code>

<p>And, in the new directory, <tt>ws1.somewhere.edu</tt> can do anything,
including edit the access control.  Here is the new ACL for
<tt>/mydata</tt>:</p>

<code> chirp:bigwig:> getacl /mydata
hostname:ws1.somewhere.edu rwlda
</code>

<p>If Betty wants to authenticate with Globus credentials from
here on, she can change the access control as follows:</p>

<code> chirp:bigwig:> setacl /mydata globus:/O=Univ_of_Somewhere/CN=Betty rwla</code>

<p>And, the new acl will look as follows:</p>

<code> chirp:bigwig:> getacl /mydata
hostname:ws1.somewhere.edu rwlda
globus:/O=Univ_of_Somewhere/CN=Betty rwla
</code>

<h3 id="security.groups">Simple Group Management<a class="sectionlink" href="#security.groups" title="Link to this section.">&#x21d7;</a></h3>

<p>Chirp currently supports a simple group management system based on files.
Create a directory on your local filesystem in which to store the groups.  Each
file in the directory will have the name of the desired groups, and contain a
list of the members of the group in plain text format.  Then, give your Chirp
server the -G argument to indicate the URL of the group directory.  Once the
groups are defined, you can refer to them in access control lists using the
<tt>group:</tt> prefix.</p>

<p>For example, suppose you wish to have two groups named
<tt>group:students</tt> and <tt>group:faculty</tt>.  You could define the
groups in the <tt>/data/groups</tt> directory as follows:</p>

<code>/data/groups/students:
unix:astudent
unix:bstudent

/data/groups/faculty:
unix:aprof
unix:bprof
</code>

<p>Then, run the chirp server with the option <tt>-G file:///data/groups</tt>.
(Notice the URL syntax.)  Then, to make a directory <tt>/homework</tt> that is
readable by students and writable by faculty, do this:</p>

<code> chirp:bigwig> mkdir /homework
 chirp:bigwig> setacl /homework group:students rl
 chirp:bigwig> setacl /homework group:faculty  rwld
</code>

<p>If the groups are to be shared among many Chirp servers, place the group
directory on a web server and refer to it via an <tt>http</tt> URL.</p>

<h3 id="security.authnotes">Notes on Authentication<a class="sectionlink" href="#security.authnotes" title="Link to this section.">&#x21d7;</a></h3>

<p>Each of the authentication types has a few things you should know:</p>

<p><b>Kerberos:</b> The server will attempt to use the Kerberos identity of
the host it is run on.  (i.e. host/coral.cs.wisc.edu@CS.WISC.EDU) Thus, it must
be run as the superuser in order to access its certificates.  Once
authentication is complete, there is no need for the server to keep its root
access, so it will change to any unprivileged user that you like.  Use the
<tt>-i</tt> option to select the userid.</p>

<p><b>Globus:</b> The server and client will attempt to perform
client authentication using the Grid Security Infrastructure (GSI)>
Both sides will load either user or host credentials, depending
on what is available.  If the server is running as an ordinary
user, then you must give a it a proxy certificate with grid-proxy-init.
Or, the server can be run as root and will use host certificates
in the usual place.</p>

<p><b>Unix:</b> This method makes use of a challenge-response in the local
Unix filesystem to determine the client's Unix identity.  It assumes that both
machines share the same conception of the user database and have a common
directory which they can read and write.  By default, the server will pick a
filename in /tmp, and challenge the client to create that file.  If it can,
then the server will examine the owner of the file to determine the client's
username.  Naturally, /tmp will only be available to clients on the same
machine.  However, if a shared filesystem directory is available, give that to
the chirp server via the -c option.  Then, any authorized client of the
filesystem can authenticate to the server.  For example, at Notre Dame, we use
<b>-c /afs/nd.edu/user37/ccl/software/rendezvous</b> to authenticate via our
AFS distributed file system.</p>

<p><b>Hostname:</b> The server will rely on a reverse DNS lookup to establish
the fully-qualified hostname of the calling client.  The second field gives the
hostname to be accepted.  It may contain an asterisk as a wildcard.  The third
field is ignored.  The fourth field is then used to select an appropriate local
username.</p>

<p><b>Address:</b> Like "hostname" authentication, except the server
simply looks at the client's IP address.</p>

<p>By default, Chirp and/or Parrot will attempt every authentication type knows
until one succeeds.  If you wish to restrict or re-order the authentication
types used, give one or more <b>-a</b> options to the client, naming the
authentication types to be used, in order. For example, to attempt only
hostname and kerberos authentication, in that order:</p>

<code><span class="prompt">$ </span>chirp -a hostname -a kerberos</code>

<h2 id="cluster">Advanced Topic: Cluster Management<a class="sectionlink" href="#cluster" title="Link to this section.">&#x21d7;</a></h2>

<p>Several tools are available for managing a large cluster of Chirp servers.</p>

<p>First, a <a href="http://www.cse.nd.edu/~ccl/viz">Java visual display
applet</a> gives a graphical view of all servers in a cluster, as well as
active network connections between each client and server.  This tool can be
used to quickly view whether storage is free or used, whether CPUs are idle or
busy, and whether the network is idle or in use.  Clicking on individual nodes
shows the same detailed data as is avaliable in the <a
href="http://catalog.cse.nd.edu:9097">catalog page</a>.</p>

<p>Next, it can be helpful to give a single 'superuser' limited access to all
servers and directories in a cluster, allowing them to fix broken access
controls and solve other problems.  To allow this, the <tt>-P user</tt>
argument can be given to a Chirp server, and will implicitly give the named
user the <b>L</b> and <b>A</b> rights on any directory on that server.</p>

<p>When managing a large system with many users, it is important to keep track
of what users are employing the cluster, and how much space they have consumed.
We refer to this as <b>auditing</b> the cluster.  To audit a single node, use
the <tt>audit</tt> command of the Chirp tool.  This produces a listing of all
users of a single host.  (You must have the <tt>A</tt> right in the root
directory of the server to run this command.) For example:</p>

<code><span class="prompt">$ </span>chirp ccl01.cse.nd.edu audit
   FILES     DIRS      DATA OWNER
   82842       27    5.0 GB globus:/O=UnivNowhere/CN=Fred
    6153      607  503.4 MB unix:fred
       2        2  200.3 MB hostname:laptop.nowhere.edu
      12        2    3.9 MB unix:betty
</code>

<p>To audit an entire cluster, run the <tt>chirp_audit_cluster</tt> tool.  This
will extract the current list of hosts from your catalog, run an audit on all
hosts in parallel, and then produce several reports in text files:
<tt>audit.users.txt</tt>, <tt>audit.hosts.txt</tt>,
<tt>audit.users.hosts.txt</tt>, and <tt>audit.hosts.users.txt</tt>.</p>

<p>Often, users of a cluster will wish to replicate commonly used data across
all disks in the system, perhaps to provide fast access to relatively static
data.  The <tt>chirp_distribute</tt> tool can be used to rapidly move data from
one node to all others.  Given a source host and path,
<tt>chirp_distribute</tt> will create a spanning tree and then move data
directly from host to host in parallel.  This is much faster than running
<tt>cp</tt> or <tt>chirp put</tt> directly.  For example, this will copy the
<tt>/database</tt> directory from host <tt>server.nd.edu</tt> to all hosts in
your cluster:</p>

<code><span class="prompt">$ </span>chirp_distribute server.nd.edu /database `chirp_status -s`</code>

<p>Another common problem is cleaning up data that has been copied this way.
To delete, simply run <tt>chirp_distribute</tt> again with the <tt>-X</tt>
option and the same arguments.</p>


<h2 id="space">Advanced Topic: Space Management<a class="sectionlink" href="#space" title="Link to this section.">&#x21d7;</a></h2>

<p>When multiple users share a common storage space, there is the danger that
one aggressive user can accidentally (or deliberately) consume all available
storage and prevent other work from happening.  Chirp has two mechanisms
available to deal with this problem.</p>

<p>The simpler tool is just a free space limit.  If run with the <tt>-F</tt>
option, a Chirp server will stop consuming space when the free space on the
disk falls below this limit.  External users will see a <tt>"No space left on
device."</tt> error.  For example, <tt>-F 100MB</tt> will leave a minimum of
100MB free on the local disk.  This mechanism imposes little or no performance
penalty on the server.</p>

<p>The more complex tool is a user-level quota and allocation system.  If run
with the <tt>-Q</tt> option, a Chirp server will establish a software quota for
all external users.  That is, <tt>-Q 2GB</tt> will limit external users to
consuming a total of 2 GB of storage within a single Chirp server.  This
mechanism imposes some run-time performance penalty, and also delays server
startup somewhere: the Chirp server must traverse its storage directory to
count up the available space.</p>

<p>With the <tt>-Q</tt> option enabled, external users can <tt>allocate</tt>
space before consuming it.  Using the Chirp tools, users may use the
<tt>mkalloc</tt> command to create new directories with an attached space
allocation.  For example, <tt>mkalloc /mydata 1GB</tt> will create a new
directory <tt>/mydata</tt> with an allocation of 1GB.  This allocation is a
<i>limit</i> that prevents files in that directory from consuming more than
1GB; it is also a <i>guarantee</i> that other users of the server will not be
able to steal the space.  Such allocations may also be subdivided by using
<tt>mkalloc</tt> to create sub-directories.</p>

<p>Note: Users employing Parrot can also use the <tt>parrot_mkalloc</tt> and
<tt>parrot_lsalloc</tt> commands in ordinary scripts to achieve the same
effect.</p>

<p>To examine an allocation, use the <tt>lsalloc</tt> command.</p>

<p>To destroy an allocation, simply delete the corresponding directory.</p>


<h2 id="tickets">Advanced Topic: Ticket Authentication<a class="sectionlink" href="#tickets" title="Link to this section.">&#x21d7;</a></h2>

<p>
  Often a user will want to access a Chirp server storing files for cluster
  computing jobs but will have difficulty accessing it securely without
  transferring their credentials with the jobs dispatched to the cluster. To
  facilitate ease-of-use, users typically solve this by giving rights to a
  hostname mask (e.g. <em>*.cse.nd.edu</em>) on the Chirp server.  However,
  this level of access can be innappropriate due to sensitive data.  Instead,
  these users are forced to use difficult authentication methods such as Globus
  or Kerberos for running the Chirp server. They may also use a virtual network
  solution but users typically lack this amount of control on clusters.  To
  provide an easy solution to this problem, Chirp offers its own ticket based
  authentication system which is convenient and simple to setup.
</p>

<p>
  To start, users may create a ticket for authentication using:
</p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt; ticket_create -output myticket.ticket -subject unix:user -bits 1024 -duration 86400 / rl /foo rwl</code>

<p>
  This command performs multiple tasks in three stages:
</p>

<p>
  First, it creates a ticket which is composed of an RSA Private Key with a key
  (modulus) size of 1024 bits. When we refer to the ticket, we are speaking of
  this Private Key. By default, the ticket file generated is named
  <strong>ticket.MD5SUM</strong> where <strong>MD5SUM</strong> is the MD5
  digest of the Public Key of the ticket.
</p>
  
<p>
  Once the ticket is created, it is registered with the Chirp server with a
  validity period in seconds defined by the duration option (86400, or a day).
  The <code>-subject unix:user</code> switch allows the user to set the ticket
  for another user; however, only the <strong>chirp_server</strong> superuser
  (-P) may set tickets for any subject. For regular users, the -subject option
  is unnecessary as it is by default the subject you possess when registering
  the ticket. Users who authenticate using this ticket in the future will
  become this subject with certain masked rights.
</p>
  
<p>
  Once the ticket is created and registered, we give the ticket a set of
  <em>ACL masks</em>. The ACL mask will mask the rights of the
  ticket-authenticated user with the rights of the subject that registered the
  ticket. For example, if a user named <em>foo</em> (subject is
  <code>unix:foo</code>) has rights <strong>rwl</strong> in the root
  directory of the Chirp server and if a ticket is registered for <em>foo</em>
  with the ACL mask <code>/ rlx</code>, the effective rights of the
  ticket-authenticated user is <strong>rl</strong> in the root directory.
</p>

<p>
  ACL masks are also inherited from parent directories. So, in the above
  example, the root directory has the ACL mask <strong>rl</strong> while the
  foo directory has the ACL mask <strong>rwl</strong>. Other nested directories
  within the root directory also inherit the <strong>rl</strong> mask.
  Similarly, nested directories of the foo directory inherit the
  <strong>rwl</strong> mask. We emphasize that the ACL mask does not give
  rights but limits them. If the user that registers a ticket has no rights in
  a directory, then neither will the ticket authenticated user.
</p>

<h3 id="tickets.auth">Authenticating with a ticket<a class="sectionlink" href="#tickets.auth" title="Link to this section.">&#x21d7;</a></h3>

<p>
  To authenticate using a ticket, it can be as simple as including the ticket
  file with your job. Tickets that follow the <strong>ticket.MD5SUM</strong>
  template are automatically added to the list of tickets to try when
  authenticating. You can also give specific tickets to authenticate with
  using a comma-delimited list of ticket filenames in either the
  <strong>CHIRP_CLIENT_TICKETS</strong> environment variable or via the
  <strong>-i &lt;tickets&gt;</strong> option. Tickets are tried in the order
  they are specified.
</p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt;</code>

<p>
  The above command will try ticket authentication as a last resort but will
  use tickets it finds in the current directory following the template.
</p>

<code><span class="prompt">$ </span>chirp -a ticket -i file.ticket &lt;host:port&gt;</code>

<p>
  The above command forces ticket authentication and only uses the
  <strong>file.ticket</strong> ticket to authenticate.
<p>

<p>
  Authenticating is this simple. It is important to note that tickets are
  obviously not protected in any way from theft when you distribute the ticket
  with jobs in a distributed computing environment (no ticket system can give
  this guarantee).  Users may want to protect their tickets in basic ways
  by setting a restrictive file mode and by giving tickets a limited duration
  on the server.
</p>

<p>
  Finally, users should be careful to experiment with small key sizes for a
  balance of quick authentication and security. Smaller key sizes may be
  rejected outright by openssl when given a 64 byte challenge to sign. Chirp
  will not authenticate or use smaller challenge sizes if openssl rejects the
  ticket.
</p>

<h3 id="tickets.register">Manually Registering a Ticket<a class="sectionlink" href="#tickets.register" title="Link to this section.">&#x21d7;</a></h3>

<p>
  A ticket is only useful when registered with a server. The ticket_create
  command does this for you automatically but you may also wish to register the
  ticket with multiple servers. To do this, you can manually register a ticket
  that is already created by using the <code>ticket_register</code> command:
</p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt; ticket_register myticket.ticket unix:user 86400</code>

<p>
  The first argument to <code>ticket_register</code> is the name of the ticket,
  followed by the subject, and finally the ticket duration.  The second option
  (the subject) is optional. As described earlier, specifying the subject
  allows you to register a ticket with a user other than yourself. This is only
  possible if you are authenticated with the server as the super user.
</p>

<h3 id="tickets.rights">Modifying the Rights of a Ticket<a class="sectionlink" href="#tickets.rights" title="Link to this section.">&#x21d7;</a></h3>

<p>
  You may use the <code>ticket_modify</code> command to change the rights
  a ticket has in a directory. You are restricted to giving rights to a 
  ticket you already possess. Recall, however, that the rights are actually
  a mask that are logically ANDed with the rights the user has at the time.
<p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt; ticket_modify myticket.ticket / rl</code>

<p>
  The above command changes the ACL mask of <code>myticket.ticket</code>
  to <code>rl</code> in the root directory.
</p>

<p>
  A ticket identifier as returned by <code>ticket_list</code> may also
  be used instead of a ticket filename.
</p>

<h3 id="tickets.delete">Deleting a Ticket<a class="sectionlink" href="#tickets.delete" title="Link to this section.">&#x21d7;</a></h3>

<p>
  Deleting a ticket unregisters the ticket with the server. Additionally,
  the ticket on the client is deleted.
</p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt; ticket_delete myticket.ticket</code>

<p>
  A ticket identifier as returned by <code>ticket_list</code> may also
  be used instead of a ticket filename.
</p>

<h3 id="tickets.list">Listing the Registered Tickets on the Server<a class="sectionlink" href="#tickets.list" title="Link to this section.">&#x21d7;</a></h3>

<p>
  To list the tickets registered on a server, use the <code>ticket_list</code>
  command:
</p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt; ticket_list unix:user</code>

<p>
  The subject argument instructs the command to fetch all the tickets belonging
  to the user. You may also use <code>ticket_list all</code> to list all the
  tickets of all users on the server. The latter command is only executable by
  the Chirp super user. The output is a list of tickets identifiers. You can
  query information about a ticket using these identifiers with the
  <code>ticket_get</code> command.
</p>

<h3 id="tickets.get">Getting a Registered Ticket's Information from the Server<a class="sectionlink" href="#tickets.get" title="Link to this section.">&#x21d7;</a></h3>

<p>
  To check the status of a ticket on a server, you may use the
  <code>ticket_get</code> command:
</p>

<code><span class="prompt">$ </span>chirp &lt;host:port&gt; ticket_get myticket.ticket</code>

<p>
  So long as you own the ticket or are authenticated as the super user, the
  server will return to you information associated with the ticket.  The ticket
  must also exist and must also not have expired.  <code>ticket_get</code>
  takes a client side ticket filename as an argument or a ticket identifier as
  returned by the <code>ticket_list</code> command.
</p>

<p>
  <code>ticket_get</code> prints the subject that owns the ticket,
  the base64 encoded public key of the ticket, the time left
  until the ticket expires in seconds, and a variable number of
  directory and ACL masks. For example, we might have the following
  output:
</p>

<code><span class="prompt">$ </span>chirp host:port ticket_get myticket.ticket
unix:pdonnel3
LS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS0KTUlHZk1BMEdDU3FHU0liM0RRRUJBUVVBQTRHTkFEQ0Jp
UUtCZ1FEZVoyZWxKYXdlcHBHK0J4SFlaMmlmWFIzNAovU3RhUElta0lmeit4TDZxN21wS2lnMDJQZ2Z5
emdKRWFjMk50NzJrUlBpOEJWYWdkOHdvSGhWc25YZ1YvNjFPCjVkaG13STNLYWRlYjNUbkZXUUo3bFhh
anhmVTZZR1hXb2VNY1BsdjVQUWloWm8yWmFXTUUvQVA4WUtnVVphdXcKelI2RkdZWGd6N2RGZzR6Yk9R
SURBUUFCCi0tLS0tRU5EIFBVQkxJQyBLRVktLS0tLQo=
5993
/ rl
/foo rwl
</code>

<p>
  Note that the base64 encoded public key above is wrapped to fit an 80
  character width for this manual. In the actual output, the public key is on
  one line. All of the information is new-line-delimited.
</p>


<h2 id="hdfs">Advanced Topic: HDFS Backend Storage for Chirp<a class="sectionlink" href="#hdfs" title="Link to this section.">&#x21d7;</a></h2>

<p>The Chirp server is able to bind to backend filesystems besides the local
filesystem. In particular, it is able to act as a frontend for the Hadoop HDFS
filesystem. When used on top of Hadoop, Chirp gives you the benefit of a robust
system of ACLs, simple userspace access and POSIX semantics (with some
limitations, discussed below). Perhaps best of all, client jobs will no longer
have any Hadoop or Java (version) dependencies.</p>

<p>To run a Chirp server as a frontend to Hadoop use the
<tt>chirp_server_hdfs</tt> command, which will set up a number of needed
environment variables and then run <tt>chirp_server</tt> with the usual
arguments.  Give the location of the root storage directory in HDFS with
<tt>-r</tt> and a URL like so:</p>

<code><span class="prompt">$ </span>chirp_server_hdfs -r hdfs://headnode.hadoop.domain.edu/mydata</code>

<p>By default, chirp will use whatever default replication factor is defined by
HDFS (typically 3).  To change the replication factor of a single file, use the
<tt>chirp setrep</tt> or <tt>parrot_setrep</tt> commands.  A path of
<tt>&amp;&amp;&amp;</tt> will set the replication factor for all new files
created in that session.</p>

<h3 id="hdfs.temporary">Temporary Local Storage<a class="sectionlink" href="#hdfs.temporary" title="Link to this section.">&#x21d7;</a></h3>

<p>Chirp allows you to setup a location to place temporary files such as those
for caching groups, and other items.  You can set this using the <tt>-y
path</tt>.  This allows for faster access, POSIX semantics, and less load on
HDFS.  By default, Chirp assumes the current directory for temporary
storage.</p>

<h3 id="hdfs.limitations">Limitations<a class="sectionlink" href="#hdfs.limitations" title="Link to this section.">&#x21d7;</a></h3>

<p>Chirp tries to preserve POSIX filesystem semantics where possible despite
HDFS violating certain assumptions. For example, random writes are not possible
for Chirp on HDFS. When the user requests to open a file for writing, Chirp
assumes an implicit <tt>O_APPEND</tt> flag was added. In addition, HDFS does
not maintain an execute permission bit for regular files. Chirp assumes all
files have the execute bit set.</p>

<p>Chirp also does not allow using the thirdput command or user space
management (<tt>-F</tt>) when using HDFS as a backend.</p>


<h2 id="jobs">Advanced Topic: Job Execution on Chirp<a class="sectionlink" href="#jobs" title="Link to this section.">&#x21d7;</a></h2>

<p>As of version 4.1.0, Chirp supports job execution. Jobs run using
executables and files located on the Chirp server. Each job descriptiong sent
to the Chirp server provides a <i>binding</i> of each file the job requires
to a local namespace (a sandbox).</p>

<p>To support the new job interface, Chirp has the following new RPC:</p>

<code>&lt;integer result&gt;                 = <b style="color: orange;">job_create</b> &lt;JSON-encoded job description&gt;
&lt;integer result&gt;                 = <b style="color: orange;">job_create</b> &lt;JSON-encoded job description&gt;
&lt;integer result&gt;                 = <b style="color: orange;">job_commit</b> &lt;JSON-encoded array of job IDs&gt;
&lt;JSON-encoded array of statuses&gt; = <b style="color: orange;">job_status</b> &lt;JSON-encoded array of job IDs&gt;
&lt;JSON-encoded array of statuses&gt; = <b style="color: orange;">job_wait</b>   &lt;job ID&gt; &lt;timeout&gt;
&lt;integer result&gt;                 = <b style="color: orange;">job_reap</b>   &lt;JSON-encoded array of job IDs&gt;
&lt;integer result&gt;                 = <b style="color: orange;">job_kill</b>   &lt;JSON-encoded array of job IDs&gt;
</code>

<p>As usual, these RPC may be sent through the Chirp client command line tool
or through the C API.</p>

<p>To enable job execution on a Chirp server, the <tt>--jobs</tt> switch must
be passed.</p>

<h3 id="jobs.create">Creating a Job<a class="sectionlink" href="#jobs.create" title="Link to this section.">&#x21d7;</a></h3>

<code>&lt;integer result&gt;                 = <b style="color: orange;">job_create</b> &lt;JSON-encoded job description&gt;</code>

<p>To create a job, you need the usual attributes of an executable to run, the
arguments to pass to the executable, any environment variables to add, and any
files to bind into the job's namespace.</p>

<p>In Chirp's Job execution framework, files are <i>bound</i> into the job's
namespace. The name of the file in the task's name space is labeled
<tt>task_path</tt> while the name in the server namespace is labeled
<tt>serv_path</tt>. <b>Files are bound in the task namespace at job start
and job end, for inputs and outputs, respectively.</b>

<h4 id="jobs.create.e1">Example 1<a class="sectionlink" href="#jobs.create.e1" title="Link to this section.">&#x21d7;</a></h4>

<code style="white-space: pre;">{
    "executable": "/bin/sh",
    "arguments": [
        "sh",
        "-c",
        "echo Hello, world! &gt; my.output"
    ],
    "files": [
        {
            "task_path": "my.output",
            "serv_path": "/users/pdonnel3/my.0.output",
            "type": "OUTPUT"
        }
    ]
}
</code>

<p>Notice that the first argument is <tt>"sh"</tt>. This argument corresponds
to <tt>argv[0]</tt> in a regular POSIX application.</p>

<p>Additionally, the output file is explicitly marked as an <tt>OUTPUT</tt>.
This file is bound into the server namespace at task completion.</p>

<h4 id="jobs.create.e2">Example 2 -- Two Inputs<a class="sectionlink" href="#jobs.create.e2" title="Link to this section.">&#x21d7;</a></h4>

<code style="white-space: pre;">{
    "executable": "/bin/tar",
    "arguments": [
        "tar",
        "-cf",
        "archive.tar",
        "a",
        "b"
    ],
    "files": [
        {
            "task_path": "a",
            "serv_path": "/users/pdonnel3/a.txt",
            "type": "INPUT",
            "binding": "SYMLINK"
        },
        {
            "task_path": "b",
            "serv_path": "/users/pdonnel3/b.txt",
            "type": "INPUT",
            "binding": "SYMLINK"
        },
        {
            "task_path": "archive.tar",
            "serv_path": "/users/pdonnel3/archive.tar",
            "type": "OUTPUT",
            "binding": "SYMLINK"
        }
    ]
}
</code>

<p>Here, each file is bound as a symbolic link the location on the server. This
type of access is usually fast as the server does not need make a copy. You may
also bind files as <tt>COPY</tt> if necessary. <tt>SYMLINK</tt> is the
default.</p>

<h4 id="jobs.create.e3">Example 3 -- Using custom executable.<a class="sectionlink" href="#jobs.create.e3" title="Link to this section.">&#x21d7;</a></h4>

<p>Often, you will have a script or executable which is present on the Chirp
server which you want to execute directly. To do this, bind the executable as
you would any other file and give a relative (task) path for the
<tt>executable</tt> job attribute:</p>

<code style="white-space: pre;">{
    "executable": "./myscript.sh",
    "arguments": [
        "myscript",
        "b",
    ],
    "files": [
        {
            "task_path": "myscript.sh",
            "serv_path": "/users/pdonnel3/myscript.sh",
            "type": "INPUT",
            "binding": "SYMLINK"
        },
        {
            "task_path": "output.txt",
            "serv_path": "/users/pdonnel3/output.txt",
            "type": "OUTPUT",
            "binding": "SYMLINK"
        }
    ]
}
</code>


<h3 id="jobs.commit">Committing (to Start) a Job<a class="sectionlink" href="#jobs.commit" title="Link to this section.">&#x21d7;</a></h3>

<code>&lt;integer result&gt;                 = <b style="color: orange;">job_commit</b> &lt;JSON-encoded array of job IDs&gt;</code>

<p>Chirp uses two-phase commit for creating a job. This serves to protect
against orphan jobs which become lost because a client or the server lose a
connection.</p>

<p>To commit a job, pass a JSON-encoded array of job identifiers to the
<tt>job_commit</tt> RPC. For example:</p>

<code><span class="prompt">$ </span>chirp host:port job_commit '[0, 1]'</code>

<p>will commit jobs <tt>0</tt> and <tt>1</tt>.

<p>Once a job is committed, the Chirp server is free to schedule and execute
the job. You may query the <a href="#jobs.status">status</a> of the job to see
if it has begun executing or <a href="#jobs.wait">wait</a> for the job to
finish.</p>


<h3 id="jobs.status">Querying the Status of a Job<a class="sectionlink" href="#jobs.status" title="Link to this section.">&#x21d7;</a></h3>

<code>&lt;JSON-encoded array of statuses&gt; = <b style="color: orange;">job_status</b> &lt;JSON-encoded array of job IDs&gt;</code>

<p>At any point in a job's lifetime, you may query its status. Status
information is JSON-encoded and holds all job metadata.</p>

<h4 id="jobs.status.e1">Example 1 -- Status of <a href="#jobs.create.e1">Create Example 1</a><a class="sectionlink" href="#jobs.status.e1" title="Link to this section.">&#x21d7;</a></h4>

<code><span class="prompt">$ </span>chirp host:port job_status '[0]'
[
  {
    "id":1,
    "error":null,
    "executable":"\/bin\/sh",
    "exit_code":null,
    "exit_status":null,
    "exit_signal":null,
    "priority":1,
    "status":"CREATED",
    "subject":"unix:pdonnel3",
    "time_commit":null,
    "time_create":"2014-02-04 23:32:02",
    "time_error":null,
    "time_finish":null,
    "time_kill":null,
    "time_start":null,
    "time_reap":null,
    "arguments":[
      "sh",
      "-c",
      "echo Hello, world! &gt; my.output"
    ],
    "environment":{
    },
    "files":[
      {
        "serv_path":"\/users\/pdonnel3\/my.0.output",
        "task_path":"my.output",
        "type":"OUTPUT",
        "binding":"SYMLINK"
      }
    ]
  }
]
</code>

<p>After we commit the job, we get this status:</p>

<code><span class="prompt">$ </span>chirp host:port job_commit '[0]'
<span class="prompt">$ </span>chirp host:port job_status '[0]'
[
  {
    "id":1,
    "error":null,
    "executable":"\/bin\/sh",
    "exit_code":null,
    "exit_status":null,
    "exit_signal":null,
    "priority":1,
    "status":"COMMITTED",
    "subject":"unix:pdonnel3",
    "time_commit":"2014-02-05 01:18:39",
    "time_create":"2014-02-04 23:32:02",
    "time_error":null,
    "time_finish":null,
    "time_kill":null,
    "time_start":null,
    "time_reap":null,
    "arguments":[
      "sh",
      "-c",
      "echo Hello, world! &gt; my.output"
    ],
    "environment":{

    },
    "files":[
      {
        "serv_path":"\/users\/pdonnel3\/my.0.output",
        "task_path":"my.output",
        "type":"OUTPUT",
        "binding":"SYMLINK"
      }
    ]
  }
]
</code>

<p>After a short time, we can again get the job's status to see that it failed:</p>

<code><span class="prompt">$ </span>chirp host:port job_status '[0]'
[
  {
    "id":1,
    "error":"No such file or directory",
    "executable":"\/bin\/sh",
    "exit_code":null,
    "exit_status":null,
    "exit_signal":null,
    "priority":1,
    "status":"ERRORED",
    "subject":"unix:pdonnel3",
    "time_commit":"2014-02-05 01:18:39",
    "time_create":"2014-02-04 23:32:02",
    "time_error":"2014-02-05 01:18:39",
    "time_finish":null,
    "time_kill":null,
    "time_start":null,
    "time_reap":null,
    "arguments":[
      "sh",
      "-c",
      "echo Hello, world! &gt; my.output"
    ],
    "environment":{

    },
    "files":[
      {
        "serv_path":"\/users\/pdonnel3\/my.0.output",
        "task_path":"my.output",
        "type":"OUTPUT",
        "binding":"SYMLINK"
      }
    ]
  }
]
</code>

<p>This is caused by <tt>/users/pdonnel3</tt> directory not existing. If we create this directory:</p>

<code><span class="prompt">$ </span>chirp host:port mkdir -p /users/pdonnel3</code>

<h4 id="jobs.status.e2">Retrying <a href="#jobs.create.e1">Create Example 1</a><a class="sectionlink" href="#jobs.status.e2" title="Link to this section.">&#x21d7;</a></h4>

<code><span class="prompt">$ </span>chirp host:port mkdir -p /users/pdonnel3
<span class="prompt">$ </span>chirp host:port job_create '{
    "executable": "/bin/sh",
    "arguments": [
        "sh",
        "-c",
        "echo Hello, world! &gt; my.output"
    ],
    "files": [
        {
            "task_path": "my.output",
            "serv_path": "/users/pdonnel3/my.0.output",
            "type": "OUTPUT"
        }
    ]
}'
<b style="color: orange;">4</b>
<span class="prompt">$ </span>chirp host:port job_commit '[4]'
<span class="prompt">$ </span>sleep 1
<span class="prompt">$ </span>chirp host:port job_status '[4]'
[
  [
    {
      "id":4,
      "error":null,
      "executable":"\/bin\/sh",
      "exit_code":0,
      "exit_status":"EXITED",
      "exit_signal":null,
      "priority":1,
      "status":"FINISHED",
      "subject":"unix:batrick",
      "time_commit":"2014-02-05 01:26:15",
      "time_create":"2014-02-05 01:25:58",
      "time_error":null,
      "time_finish":"2014-02-05 01:26:15",
      "time_kill":null,
      "time_start":"2014-02-05 01:26:15",
      "time_reap":null,
      "arguments":[
        "sh",
        "-c",
        "echo Hello, world! &gt; my.output"
      ],
      "environment":{

      },
      "files":[
        {
          "serv_path":"\/users\/pdonnel3\/my.0.output",
          "task_path":"my.output",
          "type":"OUTPUT",
          "binding":"SYMLINK"
        }
      ]
    }
  ]
]
<span class="prompt">$ </span>chirp host:port cat /users/pdonnel3/my.0.output
Hello, world!
</code>

<p>Again, you can get the status of a job at any time. However, this RPC does
not help with waiting for one or more jobs to finish. For that, we use the
<tt>job_wait</tt> RPC discussed next.</p>


<h3 id="jobs.wait">Waiting for a Job to Terminate<a class="sectionlink" href="#jobs.wait" title="Link to this section.">&#x21d7;</a></h3>

<code>&lt;JSON-encoded array of statuses&gt; = <b style="color: orange;">job_wait</b>   &lt;job ID&gt; &lt;timeout&gt;</code>

<p>Use the <tt>job_wait</tt> RPC to wait for a job to finish. This will give
you the status information of jobs which have completed and have a
<tt>status</tt> of <tt>FINISHED</tt>, <tt>KILLED</tt>, or <tt>ERRORED</tt>.</p>

<p><tt>job_wait</tt> takes an job identifier argument which matches jobs in the
following way:</p>

<table>
  <tr>
    <td style="text-align: center;"><tt style="font-weight: bold">0</tt></td>
    <td>Match all jobs for the current user.</td>
  </tr>
  <tr>
    <td style="text-align: center;"><tt style="font-weight: bold">X &gt; 0</tt></td>
    <td>Match job with id equal to <tt>X</tt>.</td>
  </tr>
  <tr>
    <td style="text-align: center;"><tt style="font-weight: bold">X &lt; 0</tt></td>
    <td>Match job with id <b>greater than</b> <tt>abs(X)</tt>.</td>
  </tr>
</table>

<p><tt>job_wait</tt> is essentially <tt>job_status</tt> except the RPC blocks
until a job matches the above condition or the <tt>timeout</tt> is
exceeded.</p>

<p>Unlike the regular UNIX wait system call, Chirp's <tt>job_wait</tt> does not
reap a job you wait for. You must do that through the <tt>job_reap</tt> RPC
discussed next.</p>


<h3 id="jobs.reap">Reaping a Finished Job<a class="sectionlink" href="#jobs.reap" title="Link to this section.">&#x21d7;</a></h3>

<code>&lt;integer result&gt;                 = <b style="color: orange;">job_reap</b>   &lt;JSON-encoded array of job IDs&gt;</code>

<p>Similar in intent to <tt>job_commit</tt>, <tt>job_reap</tt> notifies the
Chirp server that your application has logged the termination of the job. This
allows the Chirp server to reap the job. The side-effect of this operation is
future calls to <tt>job_wait</tt> will not include this job.</p>


<h3 id="jobs.kill">Killing a Job<a class="sectionlink" href="#jobs.kill" title="Link to this section.">&#x21d7;</a></h3>

<code>&lt;integer result&gt;                 = <b style="color: orange;">job_kill</b>   &lt;JSON-encoded array of job IDs&gt;</code>

<p><tt>job_kill</tt> informs the Chirp server to kill a job. Any job which has
not reached a terminal state (<tt>FINISHED</tt>, <tt>KILLED</tt>, or
<tt>ERRORED</tt>) will immediately be moved to the <tt>KILLED</tt> state. If
the job is running, the internal Chirp scheduler will also terminate the job at
its convenience.</p>


<h2 id="debugging">Debugging Advice<a class="sectionlink" href="#debugging" title="Link to this section.">&#x21d7;</a></h2>

<p>Debugging a distributed system can be quite difficult because of the sheer
number of hosts involved and the mass of information to be collected.  If you
are having difficulty with Chirp, we recommend that you make good use of the
debugging traces built into the tools.</p>

<p> In all of the Chirp and Parrot tools, the <tt>-d</tt> option allows you to
turn on selected debugging messages.  The simplest option is <tt>-d all</tt>
which will show every event that occurs in the system.</p>

<p> To best debug a problem, we recommend that you turn on the debugging
options on <b>both</b> the client and server that you are operating.  For
example, if you are having trouble getting Parrot to connect to a Chirp server,
then run both as follows:</p>

<code><span class="prompt">$ </span>chirp_server -d all [more options] ...
<span class="prompt">$ </span>parrot_run -d all tcsh
</code>

<p> Of course, this is likely to show way more information than you will be
able to process.  Instead, turn on a debugging flags selectively.  For example,
if you are having a problem with authentication, just show those messages with
<tt>-d auth</tt> on both sides.</p>

<p>There are a large number of debugging flags.  Currently, the choices are:
syscall notice channel process resolve libcall tcp dns auth local http ftp nest
chirp dcap rfio cache poll remote summary debug time pid all.  When debugging
problems with Chirp and Parrot, we recommend selectively using <tt>-d
chirp</tt>, <tt>-d tcp</tt>, <tt>-d auth</tt>, and <tt>-d libcall</tt> as
needed.</p>

</div>
</body>
</html>
