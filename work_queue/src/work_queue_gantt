#!/usr/bin/env python

# Copyright (C) 2022- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

# Packages and Definitions
import re
import sys
import json

import bokeh
from bokeh.models import ColumnDataSource, CDSView, HoverTool, GroupFilter, Range1d
from bokeh.plotting import figure, show

palette = bokeh.palettes.all_palettes["Category20"]
TOOLTIPS = [
    ("taskid", "@taskid"),
    ("category", "@category"),
    ("wait_time", "@wait_time"),
    ("start_time", "@start_time"),
    ("end_time", "@end_time"),
    ("info", "@info")
]


# Functions
def usage(status=0):
    print("work_queue_gantt")
    sys.exit(status)


def parse_log(logfile):
    tasks = {}
    with open(logfile, 'r') as log:
        p_task   = re.compile(r"(?P<time>\d+) \s+"
                              r"(?P<pid>\d+) \s+ TASK \s+"
                              r"(?P<taskid>\d+) \s+"
                              r"(?P<state>\S+) \s+"
                              r"(?P<state_args>.+)", re.X)
        p_worker = re.compile(r".*RUNNING (?P<worker>\S+)")
        p_transfer = re.compile(r"(?P<time>\d+) \s+ .* TRANSFER \s+"
                                r"(?P<state>\S+) \s+"
                                r"(?P<taskid>\d+)", re.X)

        min_time = 0

        for line in log:

            # Match for TASK entries
            m = p_task.match(line)
            if m:
                time = int(m.group("time")) / 1e6
                taskid = int(m.group("taskid"))
                state = m.group("state")

                if state == "WAITING":
                    if not min_time:
                        min_time = time
                    tasks[taskid] = {
                        "taskid": taskid,
                        "category": m.group("state_args").split()[0],
                        "wait_time": time - min_time,
                        "start_time": -1,
                        "end_time": -1,
                        "input_time": -1,
                        "output_time": -1,
                        "info": ""
                    }
                elif state == "RUNNING":
                    tasks[taskid]["start_time"] = time - min_time
                    tasks[taskid]["worker"] = p_worker.match(line).group("worker")
                elif state == "DONE":
                    tasks[taskid]["end_time"] = time - min_time
                    tasks[taskid]["info"] = m.group("state_args")

                continue

            # Match for TRANSFER entries
            m = p_transfer.match(line)
            if m:
                time   = int(m.group("time"))  / 1e6
                taskid = int(m.group("taskid"))
                state  = m.group("state")
                if state == "INPUT" and tasks[taskid]["input_time"] == -1:
                    tasks[taskid]["input_time"] = time - min_time
                if state == "OUTPUT" and tasks[taskid]["output_time"] == -1:
                    tasks[taskid]["output_time"] = time - min_time

                continue

    taskids = list(tasks.keys())
    tasks = {
        "taskid": taskids,
        **{
            key: [tasks[taskid][key] for taskid in taskids]
            for key in tasks[taskids[0]].keys()
        }
    }

    tasks["order"] = [sorted(tasks["input_time"]).index(i)
                      for i in tasks["input_time"]]

    return tasks


def get_binding(tasks):
    """
    Returns the maximum slots existed in each worker and the binding of tasks
    with slots of workers.
    """
    workers = set(tasks["worker"])
    slots   = {worker: [None] for worker in workers}
    binding = [None] * len(tasks["taskid"])

    for i in range(len(tasks["taskid"])):
        index      = tasks["order"].index(i)
        worker     = tasks["worker"][index]
        slot       = slots[worker]
        input_time = tasks["input_time"][index]
        end_time   = tasks["end_time"][index]

        bound = False
        for j in range(len(slot)):
            if not slot[j] or slot[j] <= input_time:
                binding[index] = j
                slot[j]        = end_time
                bound          = True
                break
        if not bound:
            binding[index] = len(slot)
            slot.append(end_time)

    return {worker: len(slots[worker]) for worker in workers}, binding


def plot_gantt(tasks, outfile):
    bokeh.io.output_file(outfile)

    categories = set(tasks["category"])
    colors     = palette[len(categories)]
    source     = ColumnDataSource(tasks)

    p = figure(
        title="Tasks Lifetime",
        x_axis_label="time", y_axis_label="Order of Task Start Time",
        sizing_mode="stretch_both",
    )

    for category, color in zip(categories, colors):
        view = CDSView(
            source=source,
            filters=[GroupFilter(column_name="category", group=category)]
        )
        p.hbar(
            y="order",
            left="start_time", right="end_time",
            source=source, view=view,
            color=color
        )

    p.add_tools(HoverTool(tooltips=TOOLTIPS))
    show(p)


def plot_task(tasks, outfile):
    bokeh.io.output_file(outfile)

    slots, binding   = get_binding(tasks)
    tasks["binding"] = binding

    categories = set(tasks["category"])
    workers    = set(tasks["worker"])
    colors     = palette[len(categories)]
    source     = ColumnDataSource(tasks)
    min_time   = min(tasks["input_time"])
    max_time   = max(tasks["end_time"])

    figures = {
        worker: figure(
            title=f"Tasks Lifetime for Worker {worker}",
            x_axis_label="time",
            y_axis_label="Worker Slots",
            x_range=Range1d(min_time, max_time),
        ) for worker in workers
    }

    for category, color in zip(categories, colors):
        for worker in workers:
            p = figures[worker]
            view = CDSView(
                source=source,
                filters=[
                    GroupFilter(column_name="category", group=category),
                    GroupFilter(column_name="worker",   group=worker),
                ]
            )

            for left, right, line, hatch in zip(
                    ["input_time", "start_time",  "output_time"],
                    ["start_time", "output_time", "end_time"],
                    ["black",      "black",       "black"],
                    [None,         '*',           None]
            ):
                p.hbar(
                    y="binding",
                    left=left, right=right,
                    source=source, view=view,
                    fill_color=color, line_color=line, hatch_pattern=hatch,
                    legend_label=category
                )

            p.yaxis.ticker = list(range(slots[worker]))
            p.ygrid.grid_line_alpha = 0.5
            p.ygrid.grid_line_dash = [6, 4]
            p.legend.click_policy = "hide"
            p.add_tools(HoverTool(
                tooltips=TOOLTIPS,
            ))

    show(bokeh.layouts.column(*figures.values(), sizing_mode="stretch_width"))


def plot_worker(tasks, outfile):
    bokeh.io.output_file(outfile)

    workers = set(tasks["worker"])


# Main Executions
def main():
    logfile = ""
    outfile = ""
    worker_view = False
    task_view   = False
    gantt_view  = True

    arguments = sys.argv[1:]
    while arguments:
        argument = arguments.pop(0)
        if argument[0] == '-':
            if argument == '-t':
                task_view = True
            elif argument == "-g":
                gantt_view = True
            elif argument == "-h":
                usage(0)
            elif argument == "-o":
                outfile = arguments.pop(0)
            elif argument == "-w":
                worker_view = True
            else:
                usage(1)
        logfile = argument

    if not logfile:
        print("No log file specified")
        usage(1)
    if not outfile:
        outfile = logfile + ".html"

    tasks = parse_log(logfile)
    if task_view:
        plot_task(tasks, outfile)
    elif worker_view:
        plot_worker(tasks, outfile)
    elif gantt_view:
        plot_gantt(tasks, outfile)


if __name__ == '__main__':
    main()
