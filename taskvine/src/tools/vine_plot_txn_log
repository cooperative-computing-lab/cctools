#! /usr/bin/env python

# Copyright (C) 2022- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

from collections import Counter
import matplotlib.pyplot as plt
import time
import sys
import argparse
import json

worker_info = {}
worker_of_task = {}
manager_start = -1
manager_info = {"Start":-1,
                "Connections":[],
                "Disconnections":[],
                "Resource Updates":[],
                "Cache Updates":[],
                "Tasks Sent":[],
                "Waiting Retrieval":[],
                "Marked Done":[],
                "Transfers":[],}

def parse_manager(log):
    filename = log
    lines = open(log, 'r').read().splitlines()

    for line in lines:
        if line.startswith("#"):
            continue

        try:
            (time, managerpid, subject, target, event, arg) = line.split(maxsplit=5)
        except ValueError:
            continue

        time = int(time)/1000000

        if subject == "MANAGER":
            managerpid = target
            if event == "START":
                manager_info["Start"] = time
            continue

        if subject == "WORKER":
            worker_id = target
            if worker_id == "(null)":
                continue

            if event == "CONNECTION":
                manager_info["Connections"].append(time)
            elif event == "DISCONNECTION":
                manager_info["Disconnections"].append(time)
            elif event == "RESOURCES":
                manager_info["Resource Updates"].append(time)
            elif event == "CACHE_UPDATE":
                manager_info["Cache Updates"].append(time)
            elif event == "TRANSFER":
                manager_info["Transfers"].append(time)
            continue

        if subject == "TASK":
            if event == "RUNNING":
                manager_info["Tasks Sent"].append(time)
            elif event == "WAITING_RETRIEVAL":
                manager_info["Waiting Retrieval"].append(time)
            elif event == "DONE":
                manager_info["Marked Done"].append(time)
            continue

def plot_manager(title='Manager Info', all_info=False, save=None, connections=False, disconnections=False,
                resources=False, cache_updates=False, tasks_sent=False, waiting_retrieval=False, 
                marked_done=False, input_transfers=False, output_transfers=False, xticks=None, yticks=None):

    for category in manager_info:
        if category == "Start":
            continue
        if not connections and not all_info and category == "Connections":
            continue
        if not disconnections and not all_info and category == "Disconnections":
            continue
        if not resources and not all_info and category == "Resource Updates":
            continue
        if not cache_updates and not all_info and category == "Cache Updates":
            continue
        if not tasks_sent and not all_info and category == "Tasks Sent":
            continue
        if not waiting_retrieval and not all_info and category == "Waiting Retrieval":
            continue
        if not marked_done and not all_info and category == "Marked Done":
            continue
        if not input_transfers and not all_info and category == "Input Transfers":
            continue
        if not output_transfers and not all_info and category == "Output Transfers":
            continue
        count = 1
        total = len(manager_info[category])
        xs = []
        ys = []
        for data in manager_info[category]:
            xs.append(data)
            ys.append(count/total)
            count += 1
        plt.plot(xs, ys, label=category)

    plt.title(title)
    plt.ylabel("Percent of each event completed")
    plt.xlabel("Time")
    plt.legend()
    if xticks:
        tick_list = [int(xticks[0])]
        s = tick_list[0]
        for x in range(int(xticks[2])):
            s += int(xticks[1])
            tick_list.append(s)
        plt.xticks(tick_list)
    if yticks:
        tick_list = [int(yticks[0])]
        s = tick_list[0]
        for x in range(int(yticks[2])):
            s += int(yticks[1])
            tick_list.append(s)
        plt.yticks(tick_list)
    plt.tick_params(axis='both', which='major', labelsize=15)
    if save:
        plt.savefig(save)
    plt.show()

def parse_workers(log):
    fail_count = 0
    filename = log
    lines = open(log, 'r').read().splitlines()
    for line in lines:
        if line.startswith("#"):
            continue

        try:
            (time, managerpid, subject, target, event, arg) = line.split(maxsplit=5)
        except ValueError:
            continue

        time = int(time)/1000000

        if subject == "MANAGER":
            managerpid = target
            if event == "START":
                global manager_start
                manager_start = time
            continue

        if subject == "WORKER":
            worker_id = target
            if worker_id == "(null)":
                continue

            if event == "CONNECTION":
                worker_address = arg.strip()
                if worker_id not in worker_info:
                    worker_info[worker_id] = {"host":worker_address, "connect time":time, "tasks":{}, 
                                            "cache_updates":[],"first_task":float('inf'), "resources":[],
                                            "input_transfers":[], "output_transfers":[]}
            elif event == "DISCONNECTION":
                reason = arg.strip()
                if reason == "FAILURE":
                    fail_count += 1
                if worker_id in worker_info:
                    worker_info[worker_id]["disconnect time"] = time
            elif event == "RESOURCES":
                worker_info[worker_id]["resources"].append(time)
            elif event == "CACHE_UPDATE":
                (filename, sizeinmb, walltime) = arg.split()
                worker_info[worker_id]["cache_updates"].append([time, float(walltime)/1000000, filename])
            elif event == "TRANSFER":
                (direction, filename, sizeinmb, walltime) = arg.split()
                if direction == "INPUT":
                    worker_info[worker_id]["input_transfers"].append([time, float(walltime)/1000000])
                elif direction == "OUTPUT":
                    worker_info[worker_id]["output_transfers"].append([time, float(walltime)/1000000])
            continue

        if subject == "TASK":
            taskid = target
            if event == "RUNNING":
                (worker_id, step, resources) = arg.split(maxsplit=2)
                resources = json.loads(resources)
                worker_info[worker_id]["tasks"][taskid] = {"start":time, "stop":-1}
                worker_of_task[taskid] = worker_id
                if time < worker_info[worker_id]["first_task"]:
                    worker_info[worker_id]["first_task"] = time
            elif event == "WAITING_RETRIEVAL":
                worker_id = arg.strip()
                worker_info[worker_id]["tasks"][taskid]["stop"] = time
            elif event == "DONE":
                (reason, exit_code, limits, measured) = arg.split(maxsplit=3)
                limits = json.loads(limits)
                measured = json.loads(measured)
                if reason == "SUCCESS":
                    worker_id = worker_of_task[taskid]
                    worker_info[worker_id]["tasks"][taskid]["done"] = time
            continue


def plot_resource_updates(first_task_zero):
    xs = []
    ys = []
    y = 0
    ref = manager_start
    for worker in worker_info:
        if first_task_zero:
            ref = worker_info[worker]["first_task"]
        y += 1
        for resource_update in worker_info[worker]["resources"]:
            x = resource_update - ref
            if x > 0:
                xs.append(x)
                ys.append(y)
    plt.plot(xs , ys, 'm+', label='Resource Updates')

def plot_cache_updates(first_task_zero):
    xs = []
    ys = []

    fetch_lefts=[]
    fetch_ys=[]
    fetch_widths=[]

    minitask_lefts=[]
    minitask_ys=[]
    minitask_widths=[]
    ref = manager_start
    y = 0
    for worker in worker_info:
        if first_task_zero:
            ref = worker_info[worker]["first_task"]
        y += 1
        for cache_update in worker_info[worker]["cache_updates"]:
            #  GETTING THE URL
            if cache_update[2].startswith("url"):
                for task in worker_info[worker]["tasks"]:
                    task_info = worker_info[worker]["tasks"][task]
                    update_time = cache_update[0]
                    if task_info["start"] < update_time and task_info["stop"] > update_time:
                        width = update_time - task_info["start"]
                        left =  task_info["start"] - ref
                        worker_info[worker]["tasks"][task]["start"] = update_time
                        fetch_lefts.append(left)
                        fetch_ys.append(y)
                        fetch_widths.append(width)

            # DOING THE MINITASK
            elif cache_update[2].startswith("task"):
                for task in worker_info[worker]["tasks"]:
                    task_info = worker_info[worker]["tasks"][task]
                    update_time = cache_update[0]
                    if task_info["start"] < update_time and task_info["stop"] > update_time:
                        width = update_time - task_info["start"]
                        left =  task_info["start"] - ref
                        worker_info[worker]["tasks"][task]["start"] = update_time
                        minitask_lefts.append(left)
                        minitask_ys.append(y)
                        minitask_widths.append(width)
            else:
                x = cache_update[0] - ref
                if x > 0:
                    xs.append(x)
                    ys.append(y)

    plt.plot(xs , ys, '+', color="orange", label='Cache Updates')
    plt.barh(minitask_ys, minitask_widths, left=minitask_lefts, color="red", label='Minitask')
    plt.barh(fetch_ys, fetch_widths, left=fetch_lefts, color="mistyrose", label='Curl URL')

def plot_workers(title='Worker Info', all_info=False, save=None, cache_updates=False, flip=False, resources=False, 
                    marked_done=False, input_transfers=False, output_transfers=False, xticks=None, yticks=None, first_task_zero=False):
    count = 0
    ref = manager_start
    done_xs = []
    done_ys = []
    it_lefts = []
    ot_lefts = []
    it_ys = []
    ot_ys = []
    it_widths = []
    ot_widths = []

    ys = []
    ys2 = []
    widths= []
    widths2 = []
    lefts = []
    lefts2 = []

    # PLOT CACHE UPDATES
    if all_info or cache_updates:
        plot_cache_updates(first_task_zero)

    # PLOT RESOURCES REPORTS
    if all_info or resources:
        plot_resource_updates(first_task_zero)

    for worker in worker_info:
        if first_task_zero:
            ref = worker_info[worker]["first_task"]

        count += 1

        if "tasks" in worker_info[worker]:

            t_count = 1
            
            for task in worker_info[worker]["tasks"]:
                if "start" not in worker_info[worker]["tasks"][task] or "stop" not in worker_info[worker]["tasks"][task]:
                        break
                if worker_info[worker]["tasks"][task]["stop"] == -1:
                        break

                # DONE MARKERS
                if "done" in worker_info[worker]["tasks"][task]:
                    x = worker_info[worker]["tasks"][task]["done"] - ref
                    done_xs.append(x)
                    done_ys.append(count)

                # TASKS
                if flip:
                    if t_count%2 == 1:
                        widths.append(worker_info[worker]["tasks"][task]["stop"] - worker_info[worker]["tasks"][task]["start"])
                        lefts.append(worker_info[worker]["tasks"][task]["start"] - ref)
                        ys.append(count)
                    else:
                        widths2.append(worker_info[worker]["tasks"][task]["stop"] - worker_info[worker]["tasks"][task]["start"])
                        lefts2.append(worker_info[worker]["tasks"][task]["start"] - ref)
                        ys2.append(count)
                    t_count += 1
                else:
                    widths.append(worker_info[worker]["tasks"][task]["stop"] - worker_info[worker]["tasks"][task]["start"])
                    lefts.append(worker_info[worker]["tasks"][task]["start"] - ref)
                    ys.append(count)

                # INPUT TRANSFERS
                if all_info or input_transfers:
                    for transfer in worker_info[worker]["input_transfers"]:
                        it_lefts.append(transfer[0] - ref)
                        it_ys.append(count)
                        it_widths.append(transfer[1])
                # OUTPUT TRANSFERS
                if all_info or output_transfers:
                    for transfer in worker_info[worker]["output_transfers"]:
                        ot_lefts.append(transfer[0] - ref)
                        ot_ys.append(count)
                        ot_widths.append(transfer[1])

    # PLOT TASKS
    if flip:
        plt.barh(ys, widths, left=lefts, color="blue", label='Tasks')
        plt.barh(ys2, widths2, left=lefts2, color="darkblue", label='Tasks')
    else:
        plt.barh(ys, widths, left=lefts, color='blue', label='Tasks')
    # PLOT DONE MARKERS
    if all_info or marked_done:
        plt.plot(done_xs, done_ys, 'g+', label='Marked Done')
    # PLOT INPUT TRANSFERS
    if all_info or input_transfers:
        plt.barh(it_ys, it_widths, left=it_lefts, color="black", label='Input Transfers')
    # PLOT OUTPUT TRANSFERS
    if all_info or output_transfers:
        plt.barh(ot_ys, ot_widths, left=ot_lefts, color="blue", label='Output Transfers')

    plt.title(title)
    plt.ylabel("Worker Number")
    plt.xlabel("time")
    plt.tick_params(axis='both', which='major', labelsize=15)
    plt.legend()
    if xticks:
        tick_list = [int(xticks[0])]
        s = tick_list[0]
        for x in range(int(xticks[2])):
            s += int(xticks[1])
            tick_list.append(s)
        plt.xticks(tick_list)
    if yticks:
        tick_list = [int(yticks[0])]
        s = tick_list[0]
        for x in range(int(yticks[2])):
            s += int(yticks[1])
            tick_list.append(s)
        plt.yticks(tick_list)
    if save:
        plt.savefig(save)
    plt.show()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot worker information from transaction lof file.')
    parser.add_argument('log', help='Path to transaction log file')
    parser.add_argument('mode', help='changes mode in which information can be diplayed (-Workers|-Tasks|-Manager)')
    parser.add_argument('title', nargs='?', default ='Worker Info', help='Title of the plot')
    parser.add_argument('save', nargs='?', default = None, help='Save Figure')
    parser.add_argument('-a', action='store_true', help='display all from the transaction log')
    parser.add_argument('-f', action='store_true', help='flip colors between tasks')
    parser.add_argument('-u', action='store_true', help='display cache updates')
    parser.add_argument('-r', action='store_true', help='display resource updates')
    parser.add_argument('-d', action='store_true', help='display disconnections')
    parser.add_argument('-c', action='store_true', help='display connections')
    parser.add_argument('-m', action='store_true', help='display marked done')
    parser.add_argument('-w', action='store_true', help='display waiting retrieval')
    parser.add_argument('-i', action='store_true', help='display input transfers')
    parser.add_argument('-o', action='store_true', help='display output transfers')
    parser.add_argument('-s', action='store_true', help='display tasks sent')
    parser.add_argument('-x', nargs=3, help='change scale for x ticks -x <start> <step_size> <steps>')
    parser.add_argument('-y', nargs=3, help='change scale for y ticks -y <start> <step_size> <steps>')
    parser.add_argument('-z', action='store_true', help='uses workers first task as zero')
    args = parser.parse_args()

    if args.mode == "Workers":
        parse_workers(args.log)
        plot_workers(title=args.title,
                    all_info=args.a,
                    save=args.save,
                    flip=args.f,
                    cache_updates=args.u,
                    resources=args.r,
                    marked_done=args.m,
                    input_transfers=args.i,
                    output_transfers=args.o,
                    xticks = args.x,
                    yticks = args.y,
                    first_task_zero = args.z)
    elif args.mode == "Manager":
        parse_manager(args.log)
        plot_manager(title=args.title,
                    save=args.save,
                    all_info=args.a,
                    connections = args.c,
                    disconnections = args.d,
                    resources=args.r,
                    cache_updates=args.u,
                    tasks_sent=args.s,
                    waiting_retrieval=args.w,
                    marked_done=args.m,
                    xticks = args.x,
                    yticks = args.y,
                    input_transfers=args.i,
                    output_transfers=args.o)
            
