#! /usr/bin/env python

# Copyright (C) 2022- The University of Notre Dame
# This software is distributed under the GNU General Public License.
# See the file COPYING for details.

from collections import Counter
import matplotlib.pyplot as plt
import time
import sys
import argparse
import json

plt.style.use('tableau-colorblind10')
worker_info = {}
worker_of_task = {}
first_running = float('inf')
manager_start = -1
manager_info = {"Start":-1,
                "Connections":[],
                "Disconnections":[],
                "Resource Updates":[],
                "Cache Updates":[],
                "CacheTime":{},
                "Tasks Sent":[],
                "Waiting Retrieval":[],
                "Marked Done":[],
                "Transfers":[],
                "TaskMap":{},
                "TaskDone": {},
                }

def parse_manager(log):
    lines = open(log, 'r').read().splitlines()
    for line in lines:
        if line.startswith("#"):
            continue

        try:
            (time, managerpid, subject, target, event, arg) = line.split(maxsplit=5)
        except ValueError:
            try:
                (time, managerpid, subject, target, event) = line.split(maxsplit=4)
            except ValueError:
                continue

        time = float(time)/1000000
        
        if subject == "MANAGER":
            managerpid = target
            if event == "START":
                manager_info["Start"] = time
            continue
        if subject == "WORKER":
            worker_id = target
            if worker_id == "(null)":
                continue
            if event == "CONNECTION":
                manager_info["Connections"].append(time - manager_info["Start"])
            elif event == "DISCONNECTION":
                manager_info["Disconnections"].append(time - manager_info["Start"])
            elif event == "RESOURCES":
                manager_info["Resource Updates"].append(time - manager_info["Start"])
            elif event == "CACHE_UPDATE":
                manager_info["Cache Updates"].append(time - manager_info["Start"])
            elif event == "TRANSFER":
                manager_info["Transfers"].append(time - manager_info["Start"])
            continue

        if subject == "TASK":
            if event == "RUNNING":
                manager_info["Tasks Sent"].append(time - manager_info["Start"])
            elif event == "WAITING_RETRIEVAL":
                manager_info["Waiting Retrieval"].append(time - manager_info["Start"])
            elif event == "DONE":
                manager_info["Marked Done"].append(time - manager_info["Start"])
            continue

def parse_tasks(log):
    lines = open(log, 'r').read().splitlines()
    for line in lines:
        if line.startswith("#"):
            continue

        try:
            (time, managerpid, subject, target, event, arg) = line.split(maxsplit=5)
        except ValueError:
            try:
                (time, managerpid, subject, target, event) = line.split(maxsplit=4)
            except ValueError:
                continue

        time = float(time)/1000000
        
        if subject == "MANAGER":
            managerpid = target
            if event == "START":
                manager_info["Start"] = time
            continue
        if subject == "WORKER":
            worker_id = target
            if worker_id == "(null)":
                continue
            if event == "CONNECTION":
                manager_info["Connections"].append(time - manager_info["Start"])
            elif event == "DISCONNECTION":
                manager_info["Disconnections"].append(time - manager_info["Start"])
            elif event == "RESOURCES":
                manager_info["Resource Updates"].append(time - manager_info["Start"])
            elif event == "CACHE_UPDATE":
                manager_info["Cache Updates"].append(time - manager_info["Start"])
                if float(arg.split()[-1]) != 0:
                    manager_info["CacheTime"].update([(worker_id, arg.split()[-1])])
            elif event == "TRANSFER":
                manager_info["Transfers"].append(time - manager_info["Start"])
            continue

        if subject == "TASK":
            if event == "RUNNING":
                manager_info["Tasks Sent"].append(time - manager_info["Start"])
                manager_info["TaskMap"].update([(int(target), arg.split()[0])])
            elif event == "WAITING_RETRIEVAL":
                manager_info["Waiting Retrieval"].append(time - manager_info["Start"])
                manager_info["TaskDone"].update([(int(target), time - manager_info["Start"])])
            elif event == "DONE":
                manager_info["Marked Done"].append(time - manager_info["Start"])
                
            continue

def plot_tasks(title='Manager Info', all_info=False, save=None, connections=False, disconnections=False,
                resources=False, cache_updates=False, tasks_sent=False, waiting_retrieval=False, 
                marked_done=False, input_transfers=False, output_transfers=False, xticks=None, yticks=None):

    dcache = manager_info["CacheTime"]
    dtasks = manager_info["TaskMap"]

    task_cachetime = {}

    # map cache update time to task id
    for task, worker in dtasks.items():
        for cworker, cachetime in dcache.items():
            if worker == cworker:
                task_cachetime.update([(task, cachetime)])

    stimes = list(task_cachetime.values())
    times = [float(t) for t in stimes]

    ys = range(len(manager_info["Tasks Sent"]))

    dwidths = sorted(manager_info["TaskDone"].items())
    lwidths = [float(i[1]) for i in dwidths]
    widths = [i[0] - i[1] for i in zip(lwidths, manager_info["Tasks Sent"])]

    plt.barh(ys, width=widths, left=manager_info["Tasks Sent"], label="Tasks")
    
    if input_transfers or all_info:
        plt.barh(ys, width=times, left=manager_info["Tasks Sent"], color="orange", label="Transfers")
    if waiting_retrieval or all_info:
        plt.plot(manager_info["Waiting Retrieval"], ys, "r+", label="Waiting Retrieval")
    if marked_done or all_info:
        plt.plot(manager_info["Marked Done"], ys, "g+", label="Marked Done")
    
    plt.legend()
    plt.show()
   
def plot_manager(title='Manager Info', all_info=False, save=None, connections=False, disconnections=False,
                resources=False, cache_updates=False, tasks_sent=False, waiting_retrieval=False, 
                marked_done=False, input_transfers=False, output_transfers=False, xticks=None, yticks=None):

    for category in manager_info:
        if category == "Start":
            continue
        if not connections and not all_info and category == "Connections":
            continue
        if not disconnections and not all_info and category == "Disconnections":
            continue
        if not resources and not all_info and category == "Resource Updates":
            continue
        if not cache_updates and not all_info and category == "Cache Updates":
            continue
        if not tasks_sent and not all_info and category == "Tasks Sent":
            continue
        if not waiting_retrieval and not all_info and category == "Waiting Retrieval":
            continue
        if not marked_done and not all_info and category == "Marked Done":
            continue
        if not input_transfers and not all_info and category == "Input Transfers":
            continue
        if not output_transfers and not all_info and category == "Output Transfers":
            continue
        count = 1
        total = len(manager_info[category])
        xs = []
        ys = []
        for data in manager_info[category]:
            xs.append(data)
            ys.append(count/total)
            count += 1
        plt.plot(xs, ys, label=category)

    plt.title(title)
    plt.ylabel("Percent of each event completed")
    plt.xlabel("Time")
    plt.legend()
    if xticks:
        tick_list = [int(xticks[0])]
        s = tick_list[0]
        plt.xlim(left=s)
        for x in range(int(xticks[2])):
            s += int(xticks[1])
            tick_list.append(s)
        plt.xticks(tick_list)
        plt.xlim(right=s)
    if yticks:
        tick_list = [int(yticks[0])]
        s = tick_list[0]
        plt.ylim(left=s)
        for x in range(int(yticks[2])):
            s += int(yticks[1])
            tick_list.append(s)
        plt.yticks(tick_list)
        plt.ylim(right=s)
    plt.tick_params(axis='both', which='major', labelsize=15)
    if save:
        plt.savefig(save)
    plt.show()

def parse_workers(log):
    fail_count = 0
    filename = log
    lines = open(log, 'r').read().splitlines()
    for line in lines:
        if line.startswith("#"):
            continue

        try:
            (time, managerpid, subject, target, event, arg) = line.split(maxsplit=5)
        except ValueError:
            try:
                (time, managerpid, subject, target, event) = line.split(maxsplit=4)
            except ValueError:
                continue

        time = int(time)/1000000

        if subject == "MANAGER":
            managerpid = target
            if event == "START":
                global manager_start
                manager_start = time
            continue

        if subject == "WORKER":
            worker_id = target
            if worker_id == "(null)":
                continue

            if event == "CONNECTION":
                worker_address = arg.strip()
                if worker_id not in worker_info:
                    worker_info[worker_id] = {"host":worker_address, "connect time":time, "tasks":{}, 
                                            "cache_updates":[],"first_task":float('inf'), "resources":[],
                                            "input_transfers":[], "output_transfers":[]}
            elif event == "DISCONNECTION":
                reason = arg.strip()
                if reason == "FAILURE":
                    fail_count += 1
                if worker_id in worker_info:
                    worker_info[worker_id]["disconnect time"] = time
            elif event == "RESOURCES":
                worker_info[worker_id]["resources"].append(time)
            elif event == "CACHE_UPDATE":
                (filename, sizeinmb, walltime) = arg.split()
                worker_info[worker_id]["cache_updates"].append([time, float(walltime)/1000000, filename])
            elif event == "TRANSFER":
                (direction, filename, sizeinmb, walltime) = arg.split()
                if direction == "INPUT":
                    worker_info[worker_id]["input_transfers"].append([time, float(walltime)/1000000])
                elif direction == "OUTPUT":
                    worker_info[worker_id]["output_transfers"].append([time, float(walltime)/1000000])
            continue

        if subject == "TASK":
            taskid = target
            if event == "RUNNING":
                (worker_id, step, resources) = arg.split(maxsplit=2)
                resources = json.loads(resources)
                worker_info[worker_id]["tasks"][taskid] = {"start":time, "stop":-1}
                worker_of_task[taskid] = worker_id
                if time < worker_info[worker_id]["first_task"]:
                    worker_info[worker_id]["first_task"] = time
                global first_running
                if time < first_running:
                    first_running = time
            elif event == "WAITING_RETRIEVAL":
                worker_id = arg.strip()
                worker_info[worker_id]["tasks"][taskid]["stop"] = time
            elif event == "DONE":
                (reason, exit_code, limits, measured) = arg.split(maxsplit=3)
                limits = json.loads(limits)
                measured = json.loads(measured)
                worker_start = float(measured["time_worker_start"][0])
                worker_end = float(measured["time_worker_end"][0])
                if reason == "SUCCESS":
                    worker_id = worker_of_task[taskid]
                    worker_info[worker_id]["tasks"][taskid]["done"] = time
                    worker_info[worker_id]["tasks"][taskid]["worker_start"] = worker_start
                    worker_info[worker_id]["tasks"][taskid]["worker_stop"] = worker_end
            continue


def plot_resource_updates(origin):
    xs = []
    ys = []
    y = 0
    ref = manager_start
    for worker in worker_info:
        if origin == "ManagerFirstTask":
            ref = first_running
        elif origin == "WorkerFirstTask":
            ref = worker_info[worker]["first_task"]
        y += 1
        for resource_update in worker_info[worker]["resources"]:
            x = resource_update - ref
            if x > 0:
                xs.append(x)
                ys.append(y)
    plt.plot(xs , ys, 'm+', label='Resource Updates')

def plot_cache_updates(origin):
    xs = []
    ys = []

    fetch_lefts=[]
    fetch_ys=[]
    fetch_widths=[]

    minitask_lefts=[]
    minitask_ys=[]
    minitask_widths=[]
    ref = manager_start
    y = 0
    for worker in worker_info:
        if origin == "ManagerFirstTask":
            ref = first_running
        elif origin == "WorkerFirstTask":
            ref = worker_info[worker]["first_task"]
        y += 1
        for cache_update in worker_info[worker]["cache_updates"]:
            #  GETTING THE URL
            if cache_update[2].startswith("url"):
                for task in worker_info[worker]["tasks"]:
                    task_info = worker_info[worker]["tasks"][task]
                    update_time = cache_update[0]
                    if task_info["start"] < update_time and task_info["stop"] > update_time:
                        width = update_time - task_info["start"]
                        left =  task_info["start"] - ref
                        worker_info[worker]["tasks"][task]["start"] = update_time
                        fetch_lefts.append(left)
                        fetch_ys.append(y)
                        fetch_widths.append(width)

            # DOING THE MINITASK
            elif cache_update[2].startswith("task"):
                for task in worker_info[worker]["tasks"]:
                    task_info = worker_info[worker]["tasks"][task]
                    update_time = cache_update[0]
                    if task_info["start"] < update_time and task_info["stop"] > update_time:
                        width = update_time - task_info["start"]
                        left =  task_info["start"] - ref
                        worker_info[worker]["tasks"][task]["start"] = update_time
                        minitask_lefts.append(left)
                        minitask_ys.append(y)
                        minitask_widths.append(width)
            else:
                x = cache_update[0] - ref
                if x > 0:
                    xs.append(x)
                    ys.append(y)

    plt.plot(xs , ys, '+', color="orange", label='Cache Updates')
    plt.barh(minitask_ys, minitask_widths, left=minitask_lefts, color="red", label='Minitask')
    plt.barh(fetch_ys, fetch_widths, left=fetch_lefts, color="mistyrose", label='Curl URL')

def plot_workers(title='Worker Info', all_info=False, save=None, cache_updates=False, flip=False, resources=False, 
                    marked_done=False, input_transfers=False, output_transfers=False, xticks=None, yticks=None, 
                    origin=["default"], worker_time=False):
    count = 0
    start = "start"
    stop = "stop"
    ref = manager_start
    if worker_time:
        start = "worker_start"
        stop = "worker_stop"
    done_xs = []
    done_ys = []
    wr_xs = []
    wr_ys = []
    it_lefts = []
    ot_lefts = []
    it_ys = []
    ot_ys = []
    it_widths = []
    ot_widths = []

    ys = []
    ys2 = []
    widths= []
    widths2 = []
    lefts = []
    lefts2 = []
    origin = origin[0]
    # PLOT CACHE UPDATES
    if all_info or cache_updates:
        plot_cache_updates(origin)
        
    # PLOT RESOURCES REPORTS
    if all_info or resources:
        plot_resource_updates(origin)

    for worker in worker_info:
        if origin == "ManagerFirstTask":
            ref = first_running
        elif origin == "WorkerFirstTask":
            ref = worker_info[worker]["first_task"]
    
        count += 1

        if "tasks" in worker_info[worker]:

            t_count = 1
            
            for task in worker_info[worker]["tasks"]:
                if "start" not in worker_info[worker]["tasks"][task] or "stop" not in worker_info[worker]["tasks"][task]:
                        break
                if worker_info[worker]["tasks"][task]["stop"] == -1:
                        break

                # DONE MARKERS
                if "done" in worker_info[worker]["tasks"][task]:
                    x = worker_info[worker]["tasks"][task]["done"] - ref
                    done_xs.append(x)
                    done_ys.append(count)
                # WAITING RETRIEVAL MARKERS
                if "stop" in worker_info[worker]["tasks"][task] and worker_time:
                    x = worker_info[worker]["tasks"][task]["stop"] - ref
                    wr_xs.append(x)
                    wr_ys.append(count)

                # TASKS
                if flip:
                    if t_count%2 == 1:
                        widths.append(worker_info[worker]["tasks"][task][stop] - worker_info[worker]["tasks"][task][start])
                        lefts.append(worker_info[worker]["tasks"][task]["start"] - ref)
                        ys.append(count)
                    else:
                        widths2.append(worker_info[worker]["tasks"][task][stop] - worker_info[worker]["tasks"][task][start])
                        lefts2.append(worker_info[worker]["tasks"][task]["start"] - ref)
                        ys2.append(count)
                    t_count += 1
                else:
                    widths.append(worker_info[worker]["tasks"][task][stop] - worker_info[worker]["tasks"][task][start])
                    lefts.append(worker_info[worker]["tasks"][task]["start"] - ref)
                    ys.append(count)

                # INPUT TRANSFERS
                if all_info or input_transfers:
                    for transfer in worker_info[worker]["input_transfers"]:
                        it_lefts.append(transfer[0] - ref)
                        it_ys.append(count)
                        it_widths.append(transfer[1])
                # OUTPUT TRANSFERS
                if all_info or output_transfers:
                    for transfer in worker_info[worker]["output_transfers"]:
                        ot_lefts.append(transfer[0] - ref)
                        ot_ys.append(count)
                        ot_widths.append(transfer[1])

    # PLOT TASKS
    if flip:
        plt.barh(ys, widths, left=lefts, color="blue", label='Tasks')
        plt.barh(ys2, widths2, left=lefts2, color="darkblue", label='Tasks')
    else:
        plt.barh(ys, widths, left=lefts, color='blue', label='Tasks')
    # PLOT DONE MARKERS
    if all_info or marked_done:
        plt.plot(done_xs, done_ys, 'g+', label='Marked Done')
    # PLOT DONE MARKERS
    if worker_time:
        plt.plot(wr_xs, wr_ys, 'r+', label='Waiting Retrieval')
    # PLOT INPUT TRANSFERS
    if all_info or input_transfers:
        plt.barh(it_ys, it_widths, left=it_lefts, color="black", label='Input Transfers')
    # PLOT OUTPUT TRANSFERS
    if all_info or output_transfers:
        plt.barh(ot_ys, ot_widths, left=ot_lefts, color="blue", label='Output Transfers')

    plt.title(title)
    plt.ylabel("Worker Number")
    plt.xlabel("time")
    plt.tick_params(axis='both', which='major', labelsize=15)
    plt.legend()
    if xticks:
        tick_list = [int(xticks[0])]
        s = tick_list[0]
        plt.xlim(left=s)
        for x in range(int(xticks[2])):
            s += int(xticks[1])
            tick_list.append(s)
        plt.xticks(tick_list)
        plt.xlim(right=s)
    if yticks:
        tick_list = [int(yticks[0])]
        s = tick_list[0]
        plt.ylim(left=s)
        for x in range(int(yticks[2])):
            s += int(yticks[1])
            tick_list.append(s)
        plt.yticks(tick_list)
        plt.ylim(right=s)
    if save:
        plt.savefig(save)
    plt.show()


    


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Plot worker information from transaction lof file.')
    parser.add_argument('log', help='Path to transaction log file')
    parser.add_argument('mode', help='changes mode in which information can be diplayed (-Workers|-Tasks|-Manager)')
    parser.add_argument('title', nargs='?', default ='Worker Info', help='Title of the plot')
    parser.add_argument('save', nargs='?', default = None, help='Save Figure')
    parser.add_argument('--all-info', action='store_true', help='display all from the transaction log')
    parser.add_argument('--flip-tasks', action='store_true', help='flip colors between tasks')
    parser.add_argument('--cache-updates', action='store_true', help='display cache updates')
    parser.add_argument('--resource-updates', action='store_true', help='display resource updates')
    parser.add_argument('--disconnections', action='store_true', help='display disconnections')
    parser.add_argument('--connections', action='store_true', help='display connections')
    parser.add_argument('--marked-done', action='store_true', help='display marked done')
    parser.add_argument('--waiting-retrieval', action='store_true', help='display waiting retrieval')
    parser.add_argument('--input-transfers', action='store_true', help='display input transfers')
    parser.add_argument('--output-transfers', action='store_true', help='display output transfers')
    parser.add_argument('--tasks-sent', action='store_true', help='display tasks sent')
    parser.add_argument('--xticks', nargs=3, help='change scale for x ticks -x <start> <step_size> <steps>')
    parser.add_argument('--yticks', nargs=3, help='change scale for y ticks -y <start> <step_size> <steps>')
    parser.add_argument('--origin', nargs=1, help='changes refrence point for 0 Default: manager start (WorkerFirstTask|ManagerFirstTask)', default=["default"])
    parser.add_argument('--worker-time', action='store_true', help='uses time measured on worker')
    parser.add_argument('--tex', action='store_true', help='use tex fonts')
    args = parser.parse_args()

    if args.tex:
        font = {'family' : 'serif',
                'serif': ['Computer Modern Roman'],
                'weight' : 'normal',
                'size'   : 11}
        plt.rc('font', **font)
        plt.rc('text', usetex=True)

    if args.mode == "Workers":
        parse_workers(args.log)
        plot_workers(title=args.title,
                    all_info=args.all_info,
                    save=args.save,
                    flip=args.flip_tasks,
                    cache_updates=args.cache_updates,
                    resources=args.resource_updates,
                    marked_done=args.marked_done,
                    input_transfers=args.input_transfers,
                    output_transfers=args.output_transfers,
                    xticks = args.xticks,
                    yticks = args.yticks,
                    origin=args.origin,
                    worker_time = args.worker_time)
    elif args.mode == "Manager":
        parse_manager(args.log)
        plot_manager(title=args.title,
                    save=args.save,
                    all_info=args.all_info,
                    connections = args.connections,
                    disconnections = args.disconnections,
                    resources=args.resource_updates,
                    cache_updates=args.cache_updates,
                    tasks_sent=args.tasks_sent,
                    waiting_retrieval=args.waiting_retrieval,
                    marked_done=args.marked_done,
                    xticks = args.xticks,
                    yticks = args.yticks,
                    input_transfers=args.input_transfers,
                    output_transfers=args.output_transfers)
    elif args.mode == "Tasks":
        parse_tasks(args.log)
        plot_tasks(title=args.title,
                    save=args.save,
                    all_info=args.all_info,
                    connections = args.connections,
                    disconnections = args.disconnections,
                    resources=args.resource_updates,
                    cache_updates=args.cache_updates,
                    tasks_sent=args.tasks_sent,
                    waiting_retrieval=args.waiting_retrieval,
                    marked_done=args.marked_done,
                    xticks = args.xticks,
                    yticks = args.yticks,
                    input_transfers=args.input_transfers,
                    output_transfers=args.output_transfers)
