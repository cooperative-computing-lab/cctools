/*
Copyright (C) 2022- The University of Notre Dame
This software is distributed under the GNU General Public License.
See the file COPYING for details.
*/

#include "vine_file.h"
#include "vine_task.h"

#include "debug.h"
#include "xxmalloc.h"
#include "md5.h"
#include "url_encode.h"
#include "stringtools.h"
#include "copy_stream.h"
#include "path.h"

#include <stdlib.h>
#include <unistd.h>
#include <limits.h>
#include <dirent.h>
#include <sys/stat.h>

/* Internal use: when the worker uses the client library, do not recompute cached names. */
int vine_hack_do_not_compute_cached_name = 0;

/*
For a given task and file, generate the name under which the file
should be stored in the remote cache directory.

The basic strategy is to construct a name that is unique to the
namespace from where the file is drawn, so that tasks sharing
the same input file can share the same copy.

In the common case of files, the cached name is based on the
hash of the local path, with the basename of the local path
included simply to assist with debugging.

In each of the other file types, a similar approach is taken,
including a hash and a name where one is known, or another
unique identifier where no name is available.
*/

/*
For a given file we want the generation of a cachename for said file to be injective.
This ensures the files cached at the worker are the exact files we need.

For each file type a different strategy must be used to generate the cachenames for that file.
Given that files can generally have the same name across namespaces solely using the filename is
not adequate when generating cachenames.

Preferably cachenames would always be generated using data relevant to the contents of the file.
However, this is not always available. The following discusses methods for generating cachenames
for each file type:

VINE_BUFFER - With buffers, the content of the buffer is available to us we can then use an adequate
hashing function on the contents of the buffer.

VINE_FILE - With local files, Assuming we have permission to read the given file, the contents of
the file are available for us to hash. However, due to the variable sizes of files and the number of files
that may need to be hashed, hashing can cause an unwanted amount of overhead. However, different hashing methods
can generate different changes to our overhead to be more favorable. Furthermore, it is important that any method chose
is consistent and avoids conflicts adequately. For directories, which are a subset of the VINE_FILE classification,
it is important that the directory is hashed from its contents. This can be done by using a variation of a merkle tree.
That is, each hash of a directory is a hash of the hashes of the files with the directory. This can be done recursively.

VINE_EMPTY_DIR - Are there cases where an empty directory needs to be unique?

VINE_URL - With files possibly hosted on remote machines, We generally dont have access to the contents unless one transfers
the entire file to the site of the manager which is somewhat antithetical to the use case for VINE_URLs. Here, our general strategy
is to only retrieve the header of the file from the server. With the information in the header, some fields can give us insights
to the identity of the file. More on HTTP header fields: https://www.rfc-editor.org/rfc/rfc4229#section-2.1.24
Once, the header is retrieved, fields such as Content-MD5, ETag, and Last-Modified can be used to generate the cachenames.
The following on are details on each header field used:

    	'Content-MD5' - This is an md5 digest of the entity, This field could be generated by an origin server or a client.
    	https://www.rfc-editor.org/rfc/rfc2616#page-121

    	'ETag' - an ETag or entity-tag is an "opaque" cache validator. Typically used to validate changes for a given resource.
    	There is no specification on how an ETag can be generated on a server. It could be a hash of the content, but this is not always the case.
    	ETags that begin with W/ indicate that a weak validator was used to generate the ETag.
    	https://www.rfc-editor.org/rfc/rfc2616#page-126
    	https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag

    	'Last-Modified' - This is the date and time the a resource was last changed on a server
    	https://www.rfc-editor.org/rfc/rfc2616#page-89

We then generate a hierarchy of header-fields that is equivalent to the order as they appear above. The reasoning is as follows: With md5 hashes
We can determine that two files with the same hash are the same. For ETags, we can be confident that two files are the same IF they are from the same server.
This follows for Las-Modified timestamps but an extra piece of information is needed to generate the cachename. For each header retrieved we opt for the
field that is highest on the hierarchy when present. For Last-Modified, we need an additional field to generate a cachename(as two files
can have identical last-modified dates). Currently, this is the url for the given file in addition to the server where the file is to be retrieved. For each field,
each bit of necessary information can be combined together to generate the hash.


VINE_MINITASK - A minitask is the resulting file after executing a given command on the worker. At times these commands have their own file
dependencies which have their own cachenames. There is the  possibility of generating the cachename for the minitask from the cachenames of the files
that the mini task depends on. However, certain commands have a level of dynanicism in which it we cannot use this method to adequately predict the identity
of the resulting file. It could be a possibility to just let the user decide whether a command can have a cachename. However, what happens if they are wrong?

When a cachename cannot be generated - There is an argument that if cachename cannot be generated given the present information, that the file
should not be cached. That is, generating a cachename could lead to possible conflicts on the worker side.


*/

typedef enum {
	VINE_FOUND_NONE = 0,
	VINE_FOUND_LM,
	VINE_FOUND_ET,
	VINE_FOUND_MD5,
} vine_url_cache_t;

struct vine_file *retrieve_url(const struct vine_file *f){
	char source_enc[PATH_MAX];
	url_encode(path_basename(f->source), source_enc, PATH_MAX);
	char *command = string_format("curl -sSL --stderr /dev/stdout -o \"%s\" \"%s\"", source_enc, f->source);
	FILE *stream = popen(command, "r");
	if(stream  == 0) return 0; // failed to execute curl
	int exit_status = pclose(stream);
	if(exit_status == 6) return 0; // curl could not resolve host;
	if(exit_status == 0){
		return vine_file_create(source_enc, f->remote_name, 0, 0, 0, VINE_FILE, f->flags, 0);
	}
	else {
		return 0;
	}
	return 0;
}

const char *make_mt_cached_name(const struct vine_file *f){

	unsigned char digest[MD5_DIGEST_LENGTH];
	char *buffer = vine_task_to_json(f->mini_task);
	md5_buffer(buffer,strlen(buffer),digest);
       	return md5_string(digest);

}
const char *make_url_cached_name(const struct vine_file *f)
{
	// DIRECTORY cache names might need the name of the files
	int val = VINE_FOUND_NONE;
	int STR_MAX = 256;
	char line[STR_MAX];
	char hash_src[STR_MAX];
	char *buffer;
	unsigned char digest[MD5_DIGEST_LENGTH];

	char *command = string_format("curl -I -sSL i --verbose --stderr /dev/stdout \"%s\"", f->source);
	FILE *stream = popen(command, "r");
	if(stream == 0) return 0; // curl failed to execute 
	while(fgets(line, STR_MAX, stream) != NULL){
		if(sscanf(line, "Content-MD5: %s", hash_src)){
			val = VINE_FOUND_MD5;
			break;
		}
		if(sscanf(line, "content-md5: %s", hash_src)){
			val = VINE_FOUND_MD5;
			break;
		}
		if(val < VINE_FOUND_ET && sscanf(line, "ETag: %s", hash_src)){
			val = VINE_FOUND_ET;
		}
		if(val < VINE_FOUND_ET && sscanf(line, "etag: %s", hash_src)){
			val = VINE_FOUND_ET;
		}
		if(val < VINE_FOUND_LM && sscanf(line, "Last-Modified: %s", hash_src)){
			val = VINE_FOUND_LM;
		}
		if(val < VINE_FOUND_LM && sscanf(line, "last-modified: %s", hash_src)){
			val = VINE_FOUND_LM;
		}
	}
	int exit_status = pclose(stream);
	char *prefix;
	if(exit_status != 0) return 0; // Curl executes but retuns an error
	switch(val){
		case VINE_FOUND_NONE:
			return 0;
			break;
		case VINE_FOUND_LM:
			prefix = string_format("LM-md5-");
			buffer = string_combine(hash_src, f->source); // + server
			md5_buffer(buffer,strlen(buffer),digest);
                        return string_combine(prefix, md5_string(digest));
			break;
		case VINE_FOUND_ET:
			prefix = string_format("ET-md5-");
			md5_buffer(hash_src, (strlen(hash_src)), digest); // + server
                        return string_combine(prefix, md5_string(digest));
			break;
		case VINE_FOUND_MD5:
			prefix = string_format("md5-");
			md5_buffer(hash_src, (strlen(hash_src)), digest);
                        return string_combine(prefix, md5_string(digest));
			break;
	}
	return 0;
}


char *make_cached_name( const struct vine_file *f )
{
	static unsigned int file_count = 0;
	file_count++;

	unsigned char digest[MD5_DIGEST_LENGTH];
	char source_enc[PATH_MAX];
	const char *hash;

	if(f->type == VINE_BUFFER) {
		if(f->data) {
			md5_buffer(f->data, f->length, digest);
		} else {
			md5_buffer("buffer", 6, digest);
		}
		hash = md5_string(digest);
	} else if(f->type == VINE_FILE) {
		hash = md5_file_or_dir(f->source);
		url_encode(path_basename(f->source), source_enc, PATH_MAX);
	} else if(f->type == VINE_URL){
		hash = make_url_cached_name(f);
		url_encode(path_basename(f->source), source_enc, PATH_MAX);
	} else if(f->type == VINE_MINI_TASK){
		hash = make_mt_cached_name(f);
	} else {
		md5_buffer(f->source,strlen(f->source),digest);
		hash = md5_string(digest);
		url_encode(path_basename(f->source), source_enc, PATH_MAX);
	}
	if(!hash) return 0;

	/* 0 for cache files, file_count for non-cache files. With this, non-cache
	 * files cannot be shared among tasks, and can be safely deleted once a
	 * task finishes. */
	unsigned int cache_file_id = 0;
	if(!(f->flags & VINE_CACHE)) {
		cache_file_id = file_count;
	}

	/* XXX hack to force caching for the moment */
	cache_file_id = 0;	
	switch(f->type) {
		case VINE_FILE:
			return string_format("file-%d-md5-%s-%s", cache_file_id, hash, source_enc);
			break;
		case VINE_EMPTY_DIR:
			return string_format("file-%d-md5-%s-%s", cache_file_id, md5_string(digest), source_enc);
			break;
		case VINE_MINI_TASK:
			return string_format("task-%d-md5-%s", cache_file_id, hash);
			break;
	       	case VINE_URL:
			return string_format("url-%d-%s-%s", cache_file_id, hash, source_enc);
			break;
		case VINE_TEMP:
			/* A temporary file has no initial content. */
			/* Replace with task-derived string once known. */
			{
			char cookie[17];
			string_cookie(cookie,16);
			return string_format("temp-%d-%s", cache_file_id, cookie);
			break;
			}
		case VINE_BUFFER:
		default:
			return string_format("buffer-md5-%d-%s", cache_file_id, md5_string(digest));
			break;
	}
}


/* Create a new file object with the given properties. */

struct vine_file *vine_file_create(const char *source, const char *remote_name, const char *cached_name, const char *data, int length, vine_file_t type, vine_file_flags_t flags, struct vine_task *mini_task )
{
	struct vine_file *f;

	f = xxmalloc(sizeof(*f));

	memset(f, 0, sizeof(*f));

	f->source = xxstrdup(source);
	if(remote_name) {
		f->remote_name = xxstrdup(remote_name);
	} else {
		f->remote_name = 0;
	}
	f->type = type;
	f->flags = flags;
	f->length = length;
	f->mini_task = mini_task;
	
	if(data) {
		f->data = malloc(length);
		memcpy(f->data,data,length);
	} else {
		f->data = 0;
	}
  	if(vine_hack_do_not_compute_cached_name) {
		f->cached_name = xxstrdup(f->source);
	} else if(cached_name) {
		f->cached_name = xxstrdup(cached_name);
	} else {

		char *cache_name = make_cached_name(f);
		if(cache_name == 0 && type == VINE_URL){
			struct vine_file *new_file = retrieve_url(f);
			if(!new_file){	
				unsigned char digest[MD5_DIGEST_LENGTH];
				const char *hash;
				md5_buffer(f->source,strlen(f->source),digest);
				hash = md5_string(digest);
				int rand_num = (rand() % 100000) + 1;
				f->cached_name = string_format("output-%d-%s", rand_num, hash);
				return f;
			}
			else{
		       		free(f);
				f = new_file;
				return f;
			}

		}
		else if(cache_name == 0){
			/* could not genertate cache name*/
			unsigned char digest[MD5_DIGEST_LENGTH];
			const char *hash;
			md5_buffer(f->source,strlen(f->source),digest);
			hash = md5_string(digest);
			int rand_num = (rand() % 100000) + 1;
        		f->cached_name = string_format("output-%d-%s", rand_num, hash);
			return f;
		}
		f->cached_name = cache_name;
	}
	return f;
}

/* Make a deep copy of a file object to be used independently. */

struct vine_file *vine_file_clone(const struct vine_file *f )
{
	if(!f) return 0;
	return vine_file_create(f->source,f->remote_name,f->cached_name,f->data,f->length,f->type,f->flags,vine_task_clone(f->mini_task));
}

/* Delete a file object */

void vine_file_delete(struct vine_file *f)
{
	if(!f) return;
	vine_file_delete(f->substitute);
	vine_task_delete(f->mini_task);
	free(f->source);
	free(f->remote_name);
	free(f->cached_name);
	free(f->data);
	free(f);
}

struct vine_file * vine_file_local( const char *source )
{
	return vine_file_create(source,0,0,0,0,VINE_FILE,0,0);
}

struct vine_file * vine_file_url( const char *source )
{
	return vine_file_create(source,0,0,0,0,VINE_URL,0,0);
}

struct vine_file * vine_file_substitute_url( struct vine_file *f, const char *source )
{
	return vine_file_create(source,0,f->cached_name,0,f->length,VINE_URL,0,0);
}

struct vine_file * vine_file_temp( const char *unique_name )
{
	return vine_file_create("temp",0,unique_name,0,0,VINE_TEMP,0,0);
}

struct vine_file * vine_file_buffer( const char *buffer_name,const char *data, int length )
{
	return vine_file_create(buffer_name,0,0,data,length,VINE_BUFFER,0,0);
}

struct vine_file * vine_file_empty_dir()
{
	return vine_file_create("unnamed",0,0,0,0,VINE_EMPTY_DIR,0,0);
}

struct vine_file * vine_file_mini_task( struct vine_task *t )
{
	return vine_file_create(t->command_line,0,0,0,0,VINE_MINI_TASK,0,t);
}

struct vine_file * vine_file_untar( struct vine_file *f )
{
	struct vine_task *t = vine_task_create("mkdir output && tar xf input -C output");
	vine_task_add_input(t,f,"input",VINE_CACHE);
	vine_task_add_output(t,vine_file_local("output"),"output",VINE_CACHE);
	return vine_file_mini_task(t);
}

struct vine_file * vine_file_unponcho( struct vine_file *f)
{
	struct vine_task *t  = vine_task_create("./poncho_package_run --unpack-to output -e package.tar.gz");
	char * poncho_path = path_which("poncho_package_run");
	vine_task_add_input(t, vine_file_local(poncho_path), "poncho_package_run", VINE_CACHE);
	vine_task_add_input(t, f, "package.tar.gz", VINE_CACHE);
	vine_task_add_output(t, vine_file_local("output"), "output", VINE_CACHE);
	return vine_file_mini_task(t);
}

struct vine_file * vine_file_unstarch( struct vine_file *f )
{
	struct vine_task *t = vine_task_create("SFX_DIR=output SFX_EXTRACT_ONLY=1 ./package.sfx");
	vine_task_add_input(t,f,"package.sfx",VINE_CACHE);
	vine_task_add_output(t,vine_file_local("output"),"output",VINE_CACHE);
	return vine_file_mini_task(t);
}

